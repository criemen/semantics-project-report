% !TEX root = main.tex
\section{Formalization of Dataflow with dIMP}

In this section, we are going to formalize what we mean by dataflow,
give a simple algorithm for computing dataflow and proving it is sound.

We use the toy language IMP as presented in~\cite{sat}.
The lecture notes themselves heavily borrow from~\cite{fsopl} for the
presentation and semantics of IMP.

\subsection{Syntax and Semantic of dIMP}
We extend the syntax of IMP a little bit
and call the resulting language dIMP (for dataflow IMP):
\begin{align*}
    n \in  \:       & \Z\\
    \flaggedn{} \in \: & \StoreDomain = \{\flagged{} \mid n \in \Z\}\\
    X \in  \:       & \Loc = \{x, y, z, sum, \ldots\}\\
    a \Coloneqq \: &\literalint{} \mid X \mid a_0+a_1 \mid a_0-a_1 \mid a_0 \times a_1 \mid \defaultsource\\
    t \Coloneqq \: & \btrue \mid \bfalse                                                \\
    b \Coloneqq \: & t \mid a_0 = a_1 \mid a_0 \leq a_1 \mid \neg b_0 \mid b_0 \land b_1 \\
    c \Coloneqq \: &\skipcmd \mid \defaultstore \mid \defaultseq \mid \defaultif \mid \defaultwhile \mid \defaultsink\\
    f \Coloneqq \: & \textbf{c} \mid \textbf{t}\\
\end{align*}
Stores are denoted with $\store \in \Sigma = \Loc \to \StoreDomain$.
Stores are function from locations to the set of tagged integer
values.

The intuition here is that for all $n \in \Z$, 
each value is tagged by either \textbf{c} for clean or \textbf{t} for being tracked
as having dataflow.
If the tag is irrelevant in the current context, we write $\flaggedn{}$ for a tracked
value.
A tracked value originates from a source, and is preserved by value-preserving
operations (see the semantics below).
The command $\defaultsink$ is a special marker for the dataflow sink.
It aborts the program if a tracked value reaches the sink, thus indicating a policy 
violation.
%This ensures termination for all programs that have dataflow.
In real programs, the dataflow source would likely be a procedure reading input,
i.e.\ from a terminal, and the dataflow sink would likely be a procedure 
printing the data to a terminal, or otherwise communicating with the outside world.


There is a new judgment of the form 
\fbox{$\bigstep{a}{\sigma}{\flaggedn{}}$}:
\begin{align*}
    &\bsrule{EA-Num}{}{\bigstep{\literalint}{\store}{\clean}} \qquad
    \bsrule{EA-Loc}{}{\bigstep{X}{\store}{\store(X)}}\qquad
    \bsrule{EA-Plus}
    {\bigstep{a_0}{\store}{\flagged[n_0][0]}
    \qquad \bigstep{a_1}{\store}{\flagged[n_1][1]}}
    {\bigstep{a_0+a_1}{\store}{\clean[(n_0+n_1)]}}\\
    &\bsrule{EA-Minus}
    {\bigstep{a_0}{\store}{\flagged[n_0][0]}
    \qquad \bigstep{a_1}{\store}{\flagged[n_1][1]}}
    {\bigstep{a_0-a_1}{\store}{\clean[(n_0-n_1)]}} \qquad
    \bsrule{EA-Times}
    {\bigstep{a_0}{\store}{\flagged[n_0][0]}
    \qquad \bigstep{a_1}{\store}{\flagged[n_1][1]}}
    {\bigstep{a_0 \times a_1}{\store}{\clean[(n_0 \times n_1)]}}\\
    &\bsrule{EA-Source}{\bigstep{a}{\store}{\flagged}}
    {\bigstep{\source{a}}{\store}{\tracked}}
\end{align*}

The Judgment $\langle c, \sigma \rangle \downarrow \sigma'$ is replaced by 
$\bigstep{c}{\sigma}{\excstore'}$
where $\excstore{}: (\Loc \to \StoreDomain) \cup \{\exception\}$.
The state $\exception$ indicates that the program was aborted due to a policy violation.
\\
Judgement \fbox{$\bigstep{c}{\sigma}{\excstore'}$}:
\begin{align*}
    &\bsrule{EC-Skip}{}{\bigstep{\skipcmd}{\store}{\store}}\qquad
    \bsrule{EC-Assign}{\bigstep{a}{\store}{\flaggedn{}}}
    {\bigstep{\defaultstore}{\store}{\store{}[X \mapsto \flaggedn{}]}}\\
    &\bsrule{EC-Seq}{\bigstep{c_0}{\sigma}{\store''} \qquad \bigstep{c_1}{\store''}{\excstore'}}
    {\bigstep{\defaultseq}{\store}{\excstore'}}\qquad
    \bsrule{EC-SeqAbrt}{\bigstep{c_0}{\sigma}{\exception}}
    {\bigstep{\defaultseq}{\store}{\exception}} \\
    &\bsrule{EC-IfT}{\bigstep{b}{\store}{\btrue}\qquad \bigstep{c_0}{\store}{\excstore'}}
    {\bigstep{\defaultif}{\store}{\excstore'}} \qquad
    \bsrule{EC-IfF}{\bigstep{b}{\store}{\bfalse}\qquad \bigstep{c_1}{\store}{\excstore'}}
    {\bigstep{\defaultif}{\store}{\excstore'}}\\
    &\bsrule{EC-WhileF}{\bigstep{b}{\sigma}{\bfalse}}
    {\bigstep{\defaultwhile}{\store}{\store}} \\
    &\bsrule{EC-WhileT}{\bigstep{b}{\sigma}{\btrue} \qquad \bigstep{c_0}{\store}{\store''}\qquad
    \bigstep{\defaultwhile}{\store''}{\excstore'}}
    {\bigstep{\defaultwhile}{\store}{\excstore'}}\\
    &\bsrule{EC-WhileTAbrt}{\bigstep{b}{\sigma}{\btrue} \qquad \bigstep{c_0}{\store}{\exception}}
    {\bigstep{\defaultwhile}{\store}{\exception}}\\
    &\bsrule{EC-Sink}{\bigstep{a}{\store}{\clean{}}}
    {\bigstep{\defaultsink}{\store}{\store}} \qquad
    \bsrule{EC-SinkAbrt}{\bigstep{a}{\store}{\tracked{}}}
    {\bigstep{\defaultsink}{\store}{\exception}}\\
\end{align*}

The judgement operations for booleans are modified to ignore the tracked-flag and work
just as in IMP. This is analoguous to how $\textsc{EA-Plus}$ etc.\ work.

\subsection{Syntax and Semantics of SSA-dIMP}
To facilitate the dataflow analysis, we describe a SSA form on dIMP with a concrete
syntax and semantics.
We do not describe how to transform a dIMP program to a SSA-dIMP program, but 
refer the reader to the literature, where different SSA construction algorithms are
described. Some even come with computer-verified correctness and minimality guarantees,
we refer the reader to~\cite{verifiedssa}.

The syntax for boolean and arithmetic expressions in SSA-dIMP is the same as in dIMP.
However, the command syntax changes.
We now denote commands by $s$ (statement, or SSA-command) to highlight the differences
from the commands denoted by $c$ in dIMP.
\begin{align*}
    s \Coloneqq &\:\skipcmd \mid \defaultstore \mid \defaultssaseq \mid \defaultssaif\\
    &\mid \defaultssawhile  \mid \defaultsink \\
    \philist \Coloneqq &\: \defaultphilistn\\
\end{align*}
At every point where $\varphi$ nodes can placed in the control flow graph
of a dIMP program, the syntax of SSA-dIMP has an explicit list of $\varphi$ nodes.

\subsubsection*{The SSA Type System}
A program in SSA-dIMP is only valid if it conforms to the SSA properties.
To enforce that, we describe a simple type system.
Every well-typed expression has type $\tint$, thus the set of all types is $\Tau = \{ \tint \}$.
Let $\Gamma, \Delta: \Loc \partialf \Tau$ be partial maps with finite domain.
These are the type contexts.
We define the join operator $\join$ on $\Tau$ by $\tint \join \tint = \tint$.
We will furthermore use $\dunion$ to be the union of maps, 
where we assert that the domains of the maps are disjoint.

We then show that these sets are enough to prove that the program is indeed in SSA form.
The easiest way to get these sets is to run a SSA construction algorithm on a dIMP program.
It is a gap in the provided proofs that we do not show that every dIMP program
can be transformed in a valid SSA-dIMP program (especially, we omit showing that
$\varphi$ nodes will be placed exactly at the places they are allowed in the syntax
of SSA-dIMP).
\\
Judgement \fbox{$\typestep{\Gamma}{a}{\tint}$}:
\begin{align*}
    &\trule{SSA-Num}{}{\typestep{\Gamma}{\overline{n}}{\tint}}\qquad
    \trule{SSA-Loc}{}{\typestep{\Gamma}{X}{\Gamma(X)}}\\
    &\trule{SSA-Plus}{\typestep{\Gamma}{a_0}{\tint}\qquad\typestep{\Gamma}{a_1}{\tint}}
    {\typestep{\Gamma}{a_0+a_1}{\tint}}\qquad
    \trule{SSA-Minus}{\typestep{\Gamma}{a_0}{\tint}\qquad\typestep{\Gamma}{a_1}{\tint}}
    {\typestep{\Gamma}{a_0-a_1}{\tint}}\\
    &\trule{SSA-Times}{\typestep{\Gamma}{a_0}{\tint}\qquad\typestep{\Gamma}{a_1}{\tint}}
    {\typestep{\Gamma}{a_0 \times a_1}{\tint}}\qquad
    \trule{SSA-Source}{\typestep{\Gamma}{a}{\tint}}{\typestep{\Gamma}{\source{a}}{\tint}}\\
\end{align*}
Judgement \fbox{$\typestmt{\Gamma}{b}$}:
\begin{align*}
    &\trule{SSA-Bool}{}{\typestmt{\Gamma}{t}}\qquad
    \trule{SSA-Eq}{\typestep{\Gamma}{a_0}{\tint}\qquad \typestep{\Gamma}{a_1}{\tint}}
    {\typestmt{\Gamma}{a_0 = a_1}}\\
    &\trule{SSA-Leq}{\typestep{\Gamma}{a_0}{\tint}\qquad \typestep{\Gamma}{a_1}{\tint}}
    {\typestmt{\Gamma}{a_0 \leq a_1}}\qquad
    \trule{SSA-Neg}{\typestmt{\Gamma}{b}}
    {\typestmt{\Gamma}{\neg b}}\qquad
    \trule{SSA-And}{\typestmt{\Gamma}{b_1}\qquad\typestmt{\Gamma}{b_2}}
    {\typestmt{\Gamma}{b_1 \land b_2}}\\
\end{align*}
Judgement \fbox{$\typestep{\Gamma;\Delta_0;\Delta_1}{\philist}{\Delta}$}:
\begin{align*}
    &\trule{SSA-$\varphi$}{}{\typestep{\Gamma;\Delta_0;\Delta_1}{\defaultphilistn}{[X_1 \mapsto \type_1, \ldots, X_n \mapsto \type_n]}}\\
    &\text{(if for $i \in \{1, \ldots, n\}: X_i \notin \dom\Gamma \land \type_i = (\Gamma \cup \Delta_0)(Y_i) \join (\Gamma \cup \Delta_1)(Z_i)
    \land \forall j \neq i: X_j \neq X_i$)}
\end{align*}
Note that this implies that this rule is only applicable if $Y_i$, $Z_i$ exist in the respective domains
of the partial functions.
\\
Judgement \fbox{$\typestep{\Gamma}{s}{\Delta}$}:
\begin{align*}
    &\trule{SSA-Skip}{}{\typestep{\Gamma}{\skipcmd}{\emptyset}}\qquad
    \trule{SSA-Assign}{\typestep{\Gamma}{a}{\tint}}{\typestep{\Gamma}{\defaultstore}{[X \mapsto \tint]}} \text{($X \notin \dom\Gamma$)}\\
    &\trule{SSA-Seq}{\typestep{\Gamma}{s_0}{\Delta_0}\qquad
    \typestep{\Gamma \cup \Delta_0}{s_1}{\Delta_1}}{\typestep{\Gamma}{\defaultssaseq}{\Delta_0 \cup \Delta_1}}\\
    &\trule{SSA-If}{\typestmt{\Gamma}{b}\qquad\typestep{\Gamma}{s_0}{\Delta_0}\qquad \typestep{\Gamma}{s_1}{\Delta_1}\qquad
    \typestep{\Gamma;\Delta_0;\Delta_1}{\philist}{\Delta}}
    {\typestep{\Gamma}{\defaultssaif}{\Delta}}\\
    &\trule{SSA-While}{\typestep{\Gamma;\emptyset;\Delta_1}{\philist}{\Delta}\qquad
    \typestmt{\Gamma \cup \Delta}{b}\qquad\typestep{\Gamma \cup \Delta}{s_0}{\Delta_1}}
    {\typestep{\Gamma}{\defaultssawhile}{\Delta}}\\
    &\trule{SSA-Sink}{\typestep{\Gamma}{a}{\tint}}{\typestep{\Gamma}{\sink{a}}{\emptyset}}\\
\end{align*}

Note that by this definition, the first argument of $\varphi$ nodes for \textbf{if} commands
corresponds to the variable after executing the \btrue{} branch, and the second argument to that
of the variable after executing the \bfalse{} branch.
For \textbf{while} commands, the first argument to the $\varphi$ node corresponds to the value
before executing $s_0$ the first time, and the second argument corresponds to the value 
after executing the loop body.
The sets $\Gamma$ and $\Delta$ are natural outputs of an algorithm that converts a 
dIMP program into SSA-dIMP form.
They prove that a (not necessarily minimal) SSA form was indeed achieved.
Inputs to the program are provided in the initially provided store, and $\Gamma$
has to contain the list of variables accessed by the program without definition in the program.

\subsubsection*{The Semantics of SSA-dIMP}
Stores are now partial functions $\store : \Sigma \partialf \Loc$ to indicate that
variables have to be defined before they can be read.
When updating a store, we now use the syntax 
$\store \dunion [X \mapsto \flagged{}]$ to indicate that the store $\store$ does not
contain the variable $X$.
\autoref{thm:ssa-gamma-delta-disjoint} in combination with ~\autoref{thm:ssa-progress}
justify this notation.

The judgment for booleans and arithmetic expressions does not change.
As before, we use $\excstore{}$ to denote stores that represent an \exception{}
state or a partial function, i.e.\ $\excstore{} \in (\Loc \partialf \StoreDomain) \cup \{\exception\}$
For $\varphi$ nodes, we introduce two judgements - one that evaluates all the variable definitions
to the first argument, and one that evalutes them all to the second argument.
Both judgements are provided with a filter $\filter \subseteq \dom\sigma$ that specifies which variables 
from the outer store should be kept.
The symbol $\store\restrict{\filter}$ denotes the restriction of the map $\store$
to the domain $\filter$.
In order to correctly model the execution of $\varphi$ nodes for \textbf{while} commands,
a second judgment is set up.
The regular command judmenent only populates the variables defined by the $\varphi$ nodes
and then defers to a special while-command-judgement that evaluates all loop executions,
evaluating the $\varphi$ nodes with the store after the loop body execution.
\\
Judgment \fbox{$\bigsteppl{\philist}{\filter}{\store}{\store'}$}:
\begin{align*}
    &\bsrule{E$\Phi_1$-Assign}{}
    {\bigsteppl{\defaultphilistn}{\filter}{\store}{\storeassign{\store\restrict{\filter}}{X_1 \mapsto \store(Y_1),\ldots, X_n \mapsto \store(Y_n)}}}\\
\end{align*}
Judgment \fbox{$\bigsteppr{\philist}{\filter}{\store}{\store'}$}:
\begin{align*}
    &\bsrule{E$\Phi_2$-Assign}{}
    {\bigsteppr{\defaultphilistn}{\filter}{\store}{\storeassign{\store\restrict{\filter}}{X_1 \mapsto \store(Z_1),\ldots, X_n \mapsto \store(Z_n)}}}\\
\end{align*}
\\
Judgment \fbox{$\bigstepw{s}{\filter}{\store}{\excstore'{}}$}:
\begin{align*}
    &\bsrule{EW-WhileF}{\bigstep{b}{\store}{\bfalse}}
    {\bigstepw{\defaultssawhile}{\filter}{\store}{\store}}\qquad\\
    &\bsrule{EW-WhileTAbrt}{\bigstep{b}{\store}{\btrue} \qquad 
    \bigstep{s_0}{\store}{\exception}}
    {\bigstepw{\defaultssawhile}{\filter}{\store}{\exception}}\\
    &\bsrule{EW-WhileT}{\bigstep{b}{\store}{\btrue} \enskip
    \bigstep{s_0}{\store}{\store''} \enskip
    \bigsteppr{\philist}{\filter}{\store''}{\store'''} \enskip
    \bigstepw{\defaultssawhile}{\filter}{\store'''}{\excstore'}}
    {\bigstepw{\defaultssawhile}{\filter}{\store}{\excstore'}}
\end{align*}
\\
Judgment \fbox{$\bigstep{s}{\store}{\excstore{}}$}:
\begin{align*}
    &\bsrule{EC-Skip}{}{\bigstep{\skipcmd}{\store}{\store}}\qquad
    \bsrule{EC-Assign}{\bigstep{a}{\store}{\flaggedn{}}}
    {\bigstep{\defaultstore}{\store}{\storeassign{\store}{X \mapsto \flaggedn{}}}} \\
    &\bsrule{EC-Seq}{\bigstep{s_0}{\sigma}{\store''} \qquad \bigstep{s_1}{\store''}{\excstore'}}
    {\bigstep{\defaultssaseq}{\store}{\excstore'}}\qquad
    \bsrule{EC-SeqAbrt}{\bigstep{s_0}{\sigma}{\exception}}
    {\bigstep{\defaultssaseq}{\store}{\exception}} \\
    &\bsrule{EC-IfT}{\bigstep{b}{\store}{\btrue}\qquad \bigstep{s_0}{\store}{\store''}
    \qquad \bigsteppl{\philist}{\dom\store}{\store''}{\store'}}
    {\bigstep{\defaultssaif}{\store}{\store'}}\\
    &\bsrule{EC-IfF}{\bigstep{b}{\store}{\bfalse}\qquad \bigstep{s_1}{\store}{\store''}
    \qquad \bigsteppr{\philist}{\dom\store}{\store''}{\store'}}
    {\bigstep{\defaultssaif}{\store}{\store'}}\\
    &\bsrule{EC-IfTAbrt}{\bigstep{b}{\store}{\btrue}\qquad \bigstep{s_0}{\store}{\exception}}
    {\bigstep{\defaultssaif}{\store}{\exception}} \qquad
    \bsrule{EC-IfFAbrt}{\bigstep{b}{\store}{\bfalse}\qquad \bigstep{s_1}{\store}{\exception}}
    {\bigstep{\defaultssaif}{\store}{\exception}} \\
    &\bsrule{EC-While}{\bigsteppl{\philist}{\dom\store}{\store}{\store''} \qquad
    \bigstepw{\defaultssawhile}{\dom\store}{\store''}{\excstore'}}
    {\bigstep{\defaultssawhile}{\store}{\excstore'}}\\
    &\bsrule{EC-Sink}{\bigstep{a}{\store}{\clean{}}}
    {\bigstep{\defaultsink}{\store}{\store}}\qquad
    \bsrule{EC-SinkAbrt}{\bigstep{a}{\store}{\tracked{}}}
    {\bigstep{\defaultsink}{\store}{\exception}}\\
\end{align*}

\begin{conjecture}
    We conjecture that for every dIMP program $c$ with initial store $\initialstore$
    such that $\bigstep{c}{\initialstore}{\exception}$ there exists a equivalent program
    $s$ in SSA-dIMP with sets $\Gamma, \Delta$ and an initial store $\initialstore_0$ such that
     $\bigstep{s}{\initialstore_0}{\exception}$ with
    $\dom{\initialstore_0} = \Gamma$ and $\forall X \in \Gamma: \initialstore_0(X) = \initialstore(X)$.
\end{conjecture}

We state that a SSA-dIMP program together with the SSA type derivation
is in fact in SSA form - each variable is defined only once.
Furthermore, the structure of the bigstep derivation trees imply that 
for every bigstep derivation, all variables are defined before they are used.
Proofs are omitted, as we prove these theorems in greater generality later.

\begin{theorem}
    \label{thm:ssa-gamma-delta-disjoint}
    If $\typestep{\Gamma}{s}{\Delta}$ holds, then $\Gamma \cap \Delta = \emptyset$.
\end{theorem}

\begin{theorem}
    \label{thm:ssa-progress}
    If $\typestep{\Gamma}{s}{\Delta}$, $\text{dom } \store = \Gamma$ and
    $\bigstep{s}{\store}{\store'}$, then $\store' = \store \dunion \store_0$
    and $\dom{\store_0} = \Delta$.
\end{theorem}

\subsection{Definition of Dataflow}
\begin{definition}[Program]
    A \emph{program} in dIMP is a command $c$.
    Complex programs are expressed by using the recursive nature of
    the definition of commands.
    Any program in dIMP can be transformed to be a program $s$ in SSA-dIMP with associated
    sets $\Gamma, \Delta$.
\end{definition}

\begin{definition}[Initial Store]
    An \emph{initial store} is a store $\initialstore$ s.t.\ 
    $\forall X: \exists n: \initialstore(X) = \clean[n]$.
    This means that in an initial store all values are flagged as being clean.
    We will implicitly denote inital stores by $\initialstore$.
\end{definition}

\begin{definition}[Dataflow]
    A tuple $(s, \initialstore, \Gamma, \Delta)$ of a program $s$ and initial store $\initialstore{}$ 
    with $\dom{\initialstore{}} = \Gamma$
    has \emph{dataflow from a source to a sink} if
    $\bigstep{s}{\initialstore{}}{\exception}$ holds.
    This means that the program aborts.
\end{definition}

\begin{definition}[Dataflow Algorithm]
    A \emph{dataflow algorithm} $\A(s, \Gamma, \Delta)$ computes, given a program $s$
    and a SSA type derivation $\typestep{\Gamma}{s}{\Delta}$,
    if there exists an initial store $\initialstore{}$ 
    such that $(s, \initialstore, \Gamma, \Delta)$ has dataflow from a source to a sink.
    We also require $\A(s, \Gamma, \Delta) \in \{\text{HAS\_FLOW}, \text{NO\_FLOW}, \text{UNKOWN}\}$.
\end{definition}

\begin{definition}[Soundness]
    A dataflow algorithm is \emph{sound} if for all tuples $(s, \initialstore, \Gamma, \Delta)$ that
    have dataflow it holds that $\A(s, \Gamma, \Delta) = \text{HAS\_FLOW}$ or
    $\A(s, \Gamma, \Delta) = \text{UNKNOWN}$.
\end{definition}

\begin{definition}[Completeness]
    A dataflow algorithm is \emph{complete} if $\A(s, \Gamma, \Delta) = \text{HAS\_FLOW}$
    implies that there exists an initial store $\initialstore$
     such that $(s, \initialstore, \Gamma, \Delta)$ has dataflow.
\end{definition}
\begin{definition}[False Positive]
    A program $s$ for which there exists no initial store $\initialstore$ such that 
    $(s, \initialstore, \Gamma, \Delta)$ has dataflow, but for which $\A(s, \Gamma, \Delta) = \text{HAS\_FLOW}$
    or $\A(s, \Gamma, \Delta) = \text{UNKOWN}$ holds
    is called a \emph{false positive} of the algorithm.
\end{definition}
\begin{remark}
    In general, it is impossible to construct a dataflow algorithm that is both 
    sound and complete.
    In practice, a dataflow algorithm may be neither sound nor complete.
    However, in the theoretical setting of this chapter, we are interested in 
    sound dataflow algorithms.
    The \emph{trivially sound dataflow algorithm} $\A_0(s, \Gamma, \Delta) = \text{UNKOWN}$ 
    is sound by definition, but not very interesting.
    We will not consider it further, but it is interesting to keep in mind,
    because it shows that just proving that a dataflow algorithm is sound does not
    mean it is useful.    
\end{remark}

\subsection{A General Setting For Flow Analysis}
In this section, we extend the type system presented for SSA to be viable as a
general-purpose constraint system.
This constraint system can then be solved via fixed-point iteration.
The system is designed in a way that it can be easily adapted to different analyses.
We instantiate this system to determine if programs have dataflow.

Let $\lattice$ be a poset.
Let $\join: \lattice \times \lattice \partialf \lattice$ be the (partially defined)
join operator on the poset.
We require that its domain is maximal, i.e. if $L_1, L_2 \in \lattice$ have a least upper
bound, it is $L_1 \join L_2$.
Let $\Gamma, \Delta: \Loc \partialf \lattice$ with finite domain.
Thus, we generalize the definition of $\Gamma$ and $\Delta$ here.
The previous definition can be recovered by setting $\lattice$ to be the one-point set.

For dataflow analysis, we have $\lattice = \{\lclean, \ltracked, \lunknown\}$.
Every variable encountered in the program is marked with a value in \lattice.
Thus, it is either marked with $\lclean{}$ (the variable
is clean, i.e.\ does not contain a value originating from a dataflow source), $\lunknown{}$
(it is unknown whether the variable contains a value originating from a source) or $\ltracked{}$
(the variable contains a tracked value from a dataflow source).
We define the following poset structure, where the join operator is defined on the whole
poset:
\begin{figure}[h]
    \centering
    \begin{tikzpicture}
        \node (u) at (0, 1) {$\lunknown$};
        \node (c) at (-1, 0) {$\lclean$};
        \node (t) at (1, 0) {$\ltracked$};
        \draw[->] (c) -- (u);
        \draw[->] (t) -- (u);
    \end{tikzpicture}      
\end{figure}

We introduce the following judgements:
\\
Judgement \fbox{$\typestep{\Gamma}{a}{L}$}:
\begin{align*}
    &\trule{DF-Num}{}{\typestep{\Gamma}{\overline{n}}{\lclean}}\qquad
    \trule{DF-Loc}{}{\typestep{\Gamma}{X}{\Gamma(X)}}\qquad
    \trule{DF-Plus}{\typestep{\Gamma}{a_0}{L_0}\qquad\typestep{\Gamma}{a_1}{L_1}}
    {\typestep{\Gamma}{a_0+a_1}{\lclean}}\\
    &\trule{DF-Minus}{\typestep{\Gamma}{a_0}{L_0}\qquad\typestep{\Gamma}{a_1}{L_1}}
    {\typestep{\Gamma}{a_0-a_1}{\lclean}}\qquad
    \trule{DF-Times}{\typestep{\Gamma}{a_0}{L_0}\qquad\typestep{\Gamma}{a_1}{L_1}}
    {\typestep{\Gamma}{a_0 \times a_1}{\lclean}}\\
    &\trule{DF-Source}{\typestep{\Gamma}{a}{L}}
    {\typestep{\Gamma}{\source{a}}{\ltracked}}\\
\end{align*}
Judgement \fbox{$\typestmt{\Gamma}{b}$}:
\begin{align*}
    &\trule{DF-Bool}{}{\typestmt{\Gamma}{t}}\qquad
    \trule{DF-Eq}{\typestep{\Gamma}{a_0}{L_0}\qquad \typestep{\Gamma}{a_1}{L_1}}
    {\typestmt{\Gamma}{a_0 = a_1}}\\
    &\trule{DF-Leq}{\typestep{\Gamma}{a_0}{L_0}\qquad \typestep{\Gamma}{a_1}{L_1}}
    {\typestmt{\Gamma}{a_0 \leq a_1}}\qquad
    \trule{DF-Neg}{\typestmt{\Gamma}{b}}
    {\typestmt{\Gamma}{\neg b}}\qquad
    \trule{DF-And}{\typestmt{\Gamma}{b_1}\qquad\typestmt{\Gamma}{b_2}}
    {\typestmt{\Gamma}{b_1 \land b_2}}\\
\end{align*}
\\
Judgement \fbox{$\typestep{\Gamma;\Delta_0;\Delta_1}{\philist}{\Delta}$}:
\begin{align*}
    &\trule{DF-$\varphi$}{}{\typestep{\Gamma;\Delta_0;\Delta_1}{\defaultphilistn}{[X_1 \mapsto L_1, \ldots, X_n \mapsto L_n]}}\\
    &\text{(if for $i \in \{1, \ldots, n\}: X_i \notin \dom\Gamma \land L_i = (\Gamma \dunion \Delta_0)(Y_i) \join (\Gamma \dunion \Delta_1)(Z_i)
    \land \forall j \neq i: X_j \neq X_i$)}
\end{align*}
Note that this implies that this rule is only applicable if $Y_i$, $Z_i$ exist in the respective
domains of the partial functions, and if the join exists as well.\\
Judgement \fbox{$\typestep{\Gamma}{s}{\Delta}$}:
\begin{align*}
    &\trule{DF-Skip}{}{\typestep{\Gamma}{\skipcmd}{[]}}\qquad
    \trule{DF-Assign}{\typestep{\Gamma}{a}{L}}
    {\typestep{\Gamma}{\defaultstore}{[X \mapsto L]}} \text{($X \notin \dom\Gamma$)}\\
    &\trule{DF-Seq}{\typestep{\Gamma}{s_0}{\Delta_0}\qquad
    \typestep{\Gamma \cup \Delta_0}{s_1}{\Delta_1}}{\typestep{\Gamma}{\defaultssaseq}{\Delta_0 \cup \Delta_1}}\\
    &\trule{DF-If}{\typestmt{\Gamma}{b}\qquad\typestep{\Gamma}{s_0}{\Delta_0}\qquad \typestep{\Gamma}{s_1}{\Delta_1}\qquad
    \typestep{\Gamma;\Delta_0;\Delta_1}{\philist}{\Delta}}
    {\typestep{\Gamma}{\defaultssaif}{\Delta}}\\
    &\trule{DF-While}{\typestep{\Gamma;\emptyset;\Delta_1}{\philist}{\Delta}\qquad
    \typestmt{\Gamma \cup \Delta}{b}\qquad\typestep{\Gamma \cup \Delta}{s_0}{\Delta_1}}
    {\typestep{\Gamma}{\defaultssawhile}{\Delta}}\\
    &\trule{DF-Sink}{\typestep{\Gamma}{a}{L}}{\typestep{\Gamma}{\sink{a}}{[]}}\\
\end{align*}

\begin{definition}[Store-Matching]
    Let $\gamma:\lattice \to \P(\StoreDomain)$ by defined by
    \begin{align*}
        &\gamma:\lattice \to \P(\StoreDomain)\\
        &\gamma(L) = \begin{cases}
            \{\flagged{} \mid \flagged{} \in \StoreDomain \land f = \textbf{t}\} & \text{if }L = \ltracked\\
            \{\flagged{} \mid \flagged{} \in \StoreDomain \land  f = \textbf{c}\} & \text{if }L = \lclean\\
            \StoreDomain & \text{if }L = \lunknown\\
        \end{cases}
    \end{align*}
    A store $\store$ \emph{matches a description} $\Gamma: \Loc \partialf \lattice$ if it holds that
    \begin{equation*}
        \matches{\store}{\Gamma} \longeq \dom\store = \dom\Gamma \land \forall X: \sigma(X) \in \gamma(\Gamma(X))
    \end{equation*}
\end{definition}

First, we justify why the semantics contains disjoint unions when updating stores.
Then we prove some lemmas needed to establish the soundness of our dataflow analysis.
\begin{theorem}
    \label{thm:gamma-delta-disjoint}
    If $\typestep{\Gamma}{s}{\Delta}$ holds, then $\dom\Gamma \cap \dom\Delta = \emptyset$.
\end{theorem}

\begin{lemma}
    \label{lem:gamma-arithm}
    Let $\E$ be a derivation of $\bigstep{a}{\sigma}{\flaggedn{}}$.
    If $\typestep{\Gamma}{a}{L}$ and $\matches{\store}{\Gamma}$, then $\flaggedn{} \in \gamma(L)$.
\end{lemma}

\begin{lemma}[Preservation-ish $\Phi$]
    \label{thm:preservation-phi}
    Let $\bigsteppl{\Phi}{\Theta}{\sigma''}{\sigma'}$ (or $\bigsteppr{\Phi}{\Theta}{\sigma''}{\sigma'}$),
    such that $\store'' = \store \dunion \store_0''\dunion \store{\_}$, $\matches{\store}{\Gamma}$, 
    $\matches{\store_0''}{\Delta_1}$ (or $\matches{\store_0''}{\Delta_2}$) and $\Theta = \dom\store$.
    Let $\typestep{\Gamma;\Delta_0;\Delta_1}{\Phi}{\Delta}$ by the DF rules.
    Then there exists a $\store_0$ such that $\store' = \store \dunion \store_0$
    and $\matches{\store_0}{\Delta}$.
\end{lemma}

\begin{theorem}[Preservation-ish]
    \label{thm:preservation}
    Suppose $\bigstep{s}{\store}{\store'}$ by $\E$, $\matches{\store}{\Gamma}$,
    and let $\typestep{\Gamma}{s}{\Delta}$ by $\D$ and the DF rules.
    Then there exists a $\store_0$ such that $\store' = \store \dunion \store_0$
    and $\matches{\store_0}{\Delta}$.
\end{theorem}
\begin{proof}
    We prove the theorem by induction over the derivation $\E$.\\
    \textbf{Case 1:}
    \textsc{EC-Skip}: Trivial, as $\Delta = \emptyset$.\\
    \textbf{Case 2:}
    \textsc{EC-Sink}: Trivial, as $\Delta = \emptyset$.\\
    \textbf{Case 3:}
    \begin{align*}
        &\E = \bsrule{EC-Seq}{\overset{\E_0}{\bigstep{s_0}{\sigma}{\store''}}
         \qquad \overset{\E_1}{\bigstep{s_1}{\store''}{\store'}}}
        {\bigstep{\defaultssaseq}{\store}{\store'}}\\
        &\D = \trule{DF-Seq}{\overset{\D_0}{\typestep{\Gamma}{s_0}{\Delta_0}}\qquad
        \overset{\D_1}{\typestep{\Gamma \cup \Delta_0}{s_1}{\Delta_1}}}
        {\typestep{\Gamma}{\defaultssaseq}{\Delta_0 \cup \Delta_1}}
    \end{align*}
    By assumption we have that $\matches{\store}{\Gamma}$.
    Thus, we can apply the IH on $\E_0$ with $\D_0$.
    Thus $\store'' = \store \dunion \store''_0$ and $\matches{\store''_0}{\Delta_0}$
    with $\matches{\store''}{\Gamma \union \Delta_0}$.
    Thus, we apply the IH on $\E_1$ with $\D_1$, and we get that
    $\store' = \store'' \dunion \store'_0$ and $\matches{\store'_0}{\Delta_1}$.
    Then, we have $\store' = \store \dunion \store''_0 \dunion \store'_0$
    and we can set $\store_0 = \store''_0 \dunion \store'_0$, and we obviously 
    have that $\matches{\store_0}{\Delta_0 \union \Delta_1}$.\\
    \textbf{Case 4:}
    \begin{align*}
        &\E = \bsrule{EC-IfT}{
        \overset{}{\bigstep{b}{\store}{\btrue}}\qquad 
        \overset{\E_0}{\bigstep{s_0}{\store}{\store''}}
        \qquad 
        \overset{\E_1}{\bigsteppl{\philist}{\dom\store}{\store''}{\store'}}}
        {\bigstep{\defaultssaif}{\store}{\store'}}\\
        &\D = \trule{DF-If}{
        \overset{}{\typestmt{\Gamma}{b}}\qquad
        \overset{\D_0}{\typestep{\Gamma}{s_0}{\Delta_0}}\qquad \typestep{\Gamma}{s_1}{\Delta_1}\qquad
        \overset{\D_1}{\typestep{\Gamma;\Delta_0;\Delta_1}{\philist}{\Delta}}}
        {\typestep{\Gamma}{\defaultssaif}{\Delta}}
    \end{align*}
    By IH on $\E_0$ with $\D_0$, we get that $\store'' = \store \dunion \store''_0$ and 
    $\matches{\store''_0}{\Delta_0}$.
    The result then follows from~\autoref{thm:preservation-phi} on $\E_1$ with $\D_1$.\\
    \textbf{Case 5:}
    $\E$ uses \textsc{EC-IfF}: analoguous.\\
    \textbf{Case 6:}
    \begin{align*}
        &\E = \bsrule{EC-Assign}{\overset{\E_0}{\bigstep{a}{\store}{\flaggedn{}}}}
        {\bigstep{\defaultstore}{\store}{\storeassign{\store}{X \mapsto \flaggedn{}}}}\\
        &\D = \trule{DF-Assign}{\overset{\D_0}{\typestep{\Gamma}{a}{L}}}
        {\typestep{\Gamma}{\defaultstore}{[X \mapsto L]}}
    \end{align*}
    We apply~\autoref{lem:gamma-arithm} on $\E_0$ with $\D_0$,
    and as $L$ matches $\flagged{}$, $\Delta = [X \mapsto L]$ matches the store
    $[X \mapsto \flaggedn{}]$.
    ~\autoref{thm:gamma-delta-disjoint} implies that the union in the \textsc{EC-Assign}
    rule is actually disjoint.
    \\
    \textbf{Case 7:}\\
    \begin{align*}
        &\E = \bsrule{EC-While}{\overset{\E_0}{\bigsteppl{\philist}{\dom\store}{\store}{\store''}}\qquad
        \overset{\E_2}{\bigstepw{\defaultssawhile}{\dom\store}{\store''}{\excstore'}}}
        {\bigstep{\defaultssawhile}{\store}{\store'}}\\
        &\D = \trule{DF-While}{\overset{\D_0}{\typestep{\Gamma;\emptyset;\Delta_1}{\philist}{\Delta}}\qquad
        \overset{\D_1}{\typestmt{\Gamma \cup \Delta}{b}}\qquad
        \overset{\D_2}{\typestep{\Gamma \cup \Delta}{s_0}{\Delta_1}}}
        {\typestep{\Gamma}{\defaultssawhile}{\Delta}}
    \end{align*}
    By applying~\autoref{thm:preservation-phi} on $\E_0$ with $\D_0$, we get that
    $\store'' = \store \dunion \store_0$ and $\matches{\store_0}{\Delta}$.
    Thus $\matches{\store''}{\Gamma \union \Delta}$.
    We prove the statement by an inner induction over the while derivation $\E^w$:
    \begin{claim}
        Let $\bigstepw{\defaultwhile}{\filter}{\store_w}{\store_w'}$ by $\E^w$,
         $\store_w = \store_w^0 \dunion \store_w^1$
        such that $\matches{\store_w^0}{\Gamma}$, $\Theta = \dom\store^0_w$, $\matches{\store_w^1}{\Delta}$
        and let $\typestep{\Gamma}{\defaultwhile}{\Delta}$ by $\D$ and the DF rules.
        Then we have that $\store_w' = \store_w^0 \dunion \store_0$,
        and $\matches{\store_0}{\Delta}$.
    \end{claim}
    \begin{claimproof}
        \emph{Subcase 1:}
        \begin{align*}
            \E^w = \bsrule{EW-WhileF}{
            \overset{}{\bigstep{b}{\store_w}{\bfalse}}}
            {\bigstepw{\defaultssawhile}{\filter}{\store_w}{\store_w}}
        \end{align*}
        Trivial, taking $\store_0 = \store_w^1$.\\
        \emph{Subcase 2:}
        \begin{align*}
            \E^w = \bsrule{EW-WhileT}{\overset{}{\bigstep{b}{\store_w}{\btrue}} \enskip
            \overset{\E^w_0}{\bigstep{s_0}{\store_w}{\store''}} \enskip
            \overset{\E^w_1}{\bigsteppr{\philist}{\filter}{\store''}{\store'''}} \enskip
            \overset{\E^w_2}{\bigstepw{\defaultssawhile}{\filter}{\store'''}{\excstore'}}}
            {\bigstepw{\defaultssawhile}{\filter}{\store_w}{\store_w'}}
        \end{align*}
        By the outer IH on $\E^w_0$ with $\D_2$, we get that
        $\sigma'' = \sigma_w \dunion \sigma_w'' = \sigma_w^0 \dunion \sigma_w^1 \dunion \sigma_w''$
        and $\matches{\sigma_w''}{\Delta_1}$.
        By~\autoref{thm:preservation-phi} we get that $\store''' = \store_w^0 \dunion \store_0'''$ and
        $\matches{\store_0'''}{\Delta}$.
        With that we can apply the inner induction on $\E^2_w$ with $\D$ to get the result on $\sigma_w'$.
    \end{claimproof}
    We finish the proof by applying the claim on $\E^2$ with $\D$.
\end{proof}


We then have the following (general) soundness property of the dataflow analysis:
\begin{definition}[Safe Sink]
    Let $s, \Gamma$ be such that $s = \defaultsink$ and $\typestep{\Gamma}{s}{\Delta}$ (by $\D$).
    The sink invocation $s$ is \emph{safe}, if the derivation $\D$ has the shape
    \begin{align*}
        \D = \trule{DF-Sink}{\typestep{\Gamma}{a}{L}}{\typestep{\Gamma}{\defaultsink}{\emptyset}}
    \end{align*}
    with $L = \lclean$.
\end{definition}

\begin{lemma}
    \label{lem:df-soundness}
    Let $(s, \Gamma_{ssa}, \Delta_{ssa})$ be a program in SSA form and let $\store$ be a store
    with $\dom\store = \Gamma_{ssa}$ and $\matches{\store}{\Gamma}$.
    Let $\E$ be the bigstep derivation of $\bigstep{s}{\store}{\excstore{}'}$
    and $\typestep{\Gamma}{s}{\Delta}$ (by $\D$).
    Assume that all sinks in $\E$ (with $\D$) are safe.
    Then $\excstore{}' \neq \exception$.
\end{lemma}
\begin{proof}
    Proof by induction over the derivation $\E$.
    The cases \textsc{EC-Skip}, \textsc{EC-Sink}, \textsc{EC-Assign}, \textsc{EC-IfT} and \textsc{EC-IfF}
    are trivially clear, as they never evaluate to \exception.\\
    \textbf{Case 1:}
    \begin{align*}
        \E = \bsrule{EC-SinkAbrt}{\overset{}{\bigstep{a}{\store}{\tracked{}}}}
        {\bigstep{\defaultsink}{\store}{\exception}}\\
        \D = \trule{DF-Sink}{\overset{}{\typestep{\Gamma}{a}{L}}}
        {\typestep{\Gamma}{\sink{a}}{\emptyset}}
    \end{align*}
    However, because all sinks are safe, we have $L = \lclean$.
    Furthermore, as $\store : \Gamma$ this is a contradiction,
    so this case cannot happen.\\
    \textbf{Case 2:}
    \begin{align*}
        &\E = \bsrule{EC-SeqAbrt}{\overset{\E_0}{\bigstep{s_0}{\sigma}{\exception}}}
        {\bigstep{\defaultssaseq}{\store}{\exception}}\\
        &\D = \trule{DF-Seq}{\overset{\D_0}{\typestep{\Gamma}{s_0}{\Delta_0}}\qquad
        \overset{}{\typestep{\Gamma \cup \Delta_0}{s_1}{\Delta_1}}}
        {\typestep{\Gamma}{\defaultssaseq}{\Delta_0 \cup \Delta_1}}
    \end{align*}
    By IH on $\E_0$ with $\D_0$ we get that in $\bigstep{s_0}{\store}{\excstore{}'}$ 
    we have that $\excstore{}' \neq \exception$ holds, so this case cannot happen.
    The cases for \textsc{EC-IfTAbrt} and \textsc{EC-IfFAbrt} are proved analoguous.\\
    \textbf{Case 3:}
    \begin{align*}
        &\E = \bsrule{EC-Seq}{\overset{\E_0}{\bigstep{s_0}{\sigma}{\store''}} \qquad 
        \overset{\E_1}{\bigstep{s_1}{\store''}{\excstore'}}}
        {\bigstep{\defaultssaseq}{\store}{\excstore'}}\\    
        &\D = \trule{DF-Seq}{\overset{\D_0}{\typestep{\Gamma}{s_0}{\Delta_0}}\qquad
        \overset{\D_1}{\typestep{\Gamma \cup \Delta_0}{s_1}{\Delta_1}}}
        {\typestep{\Gamma}{\defaultssaseq}{\Delta_0 \cup \Delta_1}}
    \end{align*}
    By~\autoref{thm:preservation} on $\E_0$ with $\D_0$ we get that $\matches{\store''}{\Gamma \cup \Delta_0}$.
    Then we apply the IH on $\E_1$ with $\D_1$ and get that $\excstore{}' \neq \exception$.\\
    \textbf{Case 4:}
    \begin{align*}
        &\E = \bsrule{EC-While}{\bigsteppl{\philist}{\dom\store}{\store}{\store''} \qquad
        \overset{\E_0}{\bigstepw{\defaultssawhile}{\dom\store}{\store''}{\excstore'}}}
        {\bigstep{\defaultssawhile}{\store}{\excstore'}}\\
        &\D = \trule{DF-While}{\overset{\D_0}{\typestep{\Gamma;\emptyset;\Delta_1}{\philist}{\Delta}}\qquad
        \typestmt{\Gamma \cup \Delta}{b}\qquad
        \overset{\D_1}{\typestep{\Gamma \cup \Delta}{s_0}{\Delta_1}}}
        {\typestep{\Gamma}{\defaultssawhile}{\Delta}}
    \end{align*}
    \begin{claim}
        Let $\store_w = \store_{w0} \dunion \store_{w1}$ with
        $\matches{\store_{w0}}{\Gamma}$ and $\matches{\store_{w1}}{\Delta}$,
         $\dom\Gamma = \filter$ and
        $\bigstepw{\defaultssawhile}{\filter}{\store_w}{\excstore{}'_w}$ by $\E^w$.
        Let $\typestep{\Gamma \union \Delta}{s_0}{\Delta_1}$ by $\D^w_0$
        and $\typestep{\Gamma;\emptyset;\Delta_1}{\philist}{\Delta}$ by $\D^w_1$.
        Then if all sinks in $\E^w$ are safe, $\excstore{}'_w \neq \exception$.
    \end{claim}
    \begin{claimproof}
        The case \textsc{EW-WhileF} is trivial, as it never evaluates to \exception.\\
        \emph{Subcase 1:}
        \begin{align*}
            \E^w = \bsrule{EW-WhileTAbrt}{\bigstep{b}{\store_w}{\btrue} \qquad 
            \overset{\E_0}{\bigstep{s_0}{\store_w}{\exception}}}
            {\bigstepw{\defaultssawhile}{\filter}{\store_w}{\exception}}
        \end{align*}
        By applying the outer IH on $\E_0$ with $\D^w_0$ we get that for 
        $\bigstep{s_0}{\store_w}{\excstore{}'}$ it actually holds that $\excstore{}' \neq \exception$,
        so this case cannot occur.\\
        \emph{Subcase 2:}
        \begin{align*}
            \E^w = \bsrule{EW-WhileT}{\overset{}{\bigstep{b}{\store_w}{\btrue}} \enskip
            \overset{\E^w_0}{\bigstep{s_0}{\store_w}{\store''}} \enskip
            \overset{\E^w_1}{\bigsteppr{\philist}{\filter}{\store''}{\store'''}} \enskip
            \overset{\E^w_2}{\bigstepw{\defaultssawhile}{\filter}{\store'''}{\excstore'_w}}}
            {\bigstepw{\defaultssawhile}{\filter}{\store_w}{\store_w'}}
        \end{align*}
        By~\autoref{thm:preservation} on $\E^w_0$ with $\D^w_0$, we get that $\store'' = \store_w \dunion \store''_0$
        and $\matches{\store''_0}{\Delta_1}$, thus $\matches{\store''}{\Gamma \union \Delta \dunion \Delta_1}$.
        By~\autoref{thm:preservation-phi} on $\E^w_1$ with $\D_1^w$ it follows that $\store''' = \store_{w0} \dunion \store'''_0$
        with $\matches{\store'''_0}{\Delta}$.
        Thus $\matches{\store'''}{\Gamma \union \Delta}$ and we can apply the inner IH on $\E^w_2$.
        That implies that $\excstore{}'_w \neq \exception$.
    \end{claimproof}
    We apply the claim on $\E_0$ with $\D_0$ and $\D_1$.
\end{proof}

\begin{theorem}[Soundness of the DF rules]
    Let $(s, \Gamma_{ssa}, \Delta_{ssa})$ be a program in SSA form and let $\store$ be a store
    with $\dom\store = \Gamma_{ssa}$.
    Let $\E$ be the bigstep derivation of $\bigstep{s}{\store}{\excstore{}'}$.
    Let $\Gamma: \Gamma_{ssa} \partialf \lattice$ be defined by
    \begin{align*}
        \Gamma(X) \mapsto \begin{cases}
            \lclean & \text{if $\exists n \in \Z: \store(X) = \clean$}\\
            \ltracked & \text{if $\exists n \in \Z: \store(X) = \tracked{}$}\\
        \end{cases}
    \end{align*}
    and let $\typestep{\Gamma}{s}{\Delta}$ (by $\D$).
    If all sinks in $\D$ are safe, then $\excstore{}' \neq \exception$.
\end{theorem}
\begin{proof}
    We have that $\matches{\store}{\Gamma}$ by construction.
    Thus we can apply~\autoref{lem:df-soundness} to prove the theorem.
\end{proof}

We now describe a sound dataflow algorithm $\A(s, \Gamma_\text{ssa}, \Delta_\text{ssa})$.
First, define $\Gamma$ by
\begin{align*}
    \Gamma: &\Gamma_s \to \lattice\\
    &X \mapsto \lclean
\end{align*}
Then, by fixpoint iteration using the DF rules, a map $\Delta$ and a derivation tree $\D$ 
are computed such that
$\typestep{\Gamma}{s}{\Delta}$ (by $\D$) holds.
As the poset $\lattice$ is finite, the fixpoint iteration terminates.
The algorithm then outputs \text{HAS\_FLOW} if $\D$ contains a derivation of form
\begin{equation*}
    \trule{DF-Sink}{\typestep{\Gamma}{a}{\ltracked}}{\typestep{\Gamma}{\sink{a}}{\emptyset}}
\end{equation*}
and, in the absence of that, outputs \text{UNKOWN} if $\D$ contains a derivation of form
\begin{equation*}
    \trule{DF-Sink}{\typestep{\Gamma}{a}{\lunknown}}{\typestep{\Gamma}{\sink{a}}{\emptyset}}
\end{equation*}
and, in the absence of that, outputs \text{NO\_FLOW}.

\begin{corollary}
    The algorithm $\A(s, \Gamma_\text{ssa}, \Delta_\text{ssa})$ is a sound dataflow algorithm.
\end{corollary}
