% !TEX root = main.tex
\section{Formalization of Dataflow with dIMP}

In this section, we are going to formalize what we mean by dataflow,
give a simple algorithm for computing dataflow and proving it is sound.
We will furthermore use this formalization to prove that our
path-sensitivity extension of the dataflow algorithm preserves soundness.

We use the toy language IMP as presented in~\cite{sat}.
The lecture notes themselves heavily borrow from~\cite{fsopl} for the
presentation and semantics of IMP.
We assume that the reader is familiar with the syntax and semantics of IMP
as presented in section 2.1 of~\cite{sat}.

% expr, store, result
\newcommand{\bigstep}[3]{\langle #1, #2 \rangle \downarrow #3}
\newcommand{\bigstepderiv}[4]{\overset{#1}{\langle #2, #3 \rangle \downarrow #4}}
\newcommand{\bigstepw}[4]{\langle #1, #2, #3 \rangle \downarrow^w #4}
\newcommand{\bigsteppl}[4]{\langle #1, #2, #3 \rangle \downarrow^{\Phi1} #4}
\newcommand{\bigsteppr}[4]{\langle #1, #2, #3 \rangle \downarrow^{\Phi2} #4}
\newcommand{\typestep}[3]{#1 \vdash {#2}: #3}
\newcommand{\typestmt}[2]{#1 \vdash {#2}}
% name, requirement, result
\newcommand{\bsrule}[3]{\textsc{#1}\ddfrac{#2}{#3}}
\let\rule\undefined
\newcommand{\rule}[3]{\textsc{#1}\ddfrac{#2}{#3}}
\newcommand{\literalint}[1][n]{\bar{#1}}
\newcommand{\store}[1][\sigma]{#1}
%\newcommand{\clean}[1][n]{#1^\textbf{c}}
%\newcommand{\tracked}[1][n]{#1^\textbf{t}}
%\newcommand{\flagged}[1][n]{#1^f}
\NewDocumentCommand{\clean}{O{n}+o}{{#1}_{[\textbf{c}\IfValueT{#2}{_#2}]}}
\NewDocumentCommand{\tracked}{O{n}+o}{{#1}_{[\textbf{t}\IfValueT{#2}{_#2}]}}
\NewDocumentCommand{\flagged}{O{n}+o}{{#1}_{[{f}\IfValueT{#2}{_#2}]}}
\newcommand{\source}[1]{\textbf{source }{#1}}
\newcommand{\defaultsource}{\source{a}}
\newcommand{\sink}[1]{\textbf{sink }{#1}}
\newcommand{\defaultsink}{\sink{a}}
\newcommand{\excstore}[1][\sigma]{\hat{#1}}
\newcommand{\initialstore}[1][\sigma]{\tilde{#1}}
\newcommand{\Loc}{\textbf{Loc}}
\newcommand{\partialf}{\rightharpoonup} %{\dashrightarrow}
\newcommand{\StoreDomain}{\tilde{Z}}
\newcommand{\exception}{\textbf{abrt}}
\newcommand{\skipcmd}{\textbf{skip}}
\newcommand{\seq}[2]{{#1}; {#2}}
\newcommand{\defaultseq}{\seq{c_0}{c_1}}
\newcommand{\defaultssaseq}{\seq{s_0}{s_1}}
\newcommand{\ifcmd}[3]{\textbf{if }{#1} \textbf{ then }{#2}\textbf{ else }{#3}}
\newcommand{\defaultif}{\ifcmd{b}{c_0}{c_1}}
\newcommand{\btrue}{\textbf{true}}
\newcommand{\bfalse}{\textbf{false}}
\newcommand{\whilecmd}[2]{\textbf{while }{#1} \textbf{ do } {#2}}
\newcommand{\defaultwhile}{\whilecmd{b}{c_0}}
\newcommand{\storecmd}[2]{{#1} \coloneqq {#2}}
\newcommand{\defaultstore}{\storecmd{X}{a}}
\newcommand{\phistore}[3]{{#1} \coloneqq \varphi({#2}, {#3})}
\newcommand{\philist}{\Phi}
\newcommand{\defaultphi}{\phistore{X_1}{Y_1}{Z_1}, \ldots}
\newcommand{\defaultphilist}{[\defaultphi]}
\newcommand{\defaultphilistn}{[\defaultphi, \phistore{X_n}{Y_n}{Z_n}]}
\newcommand{\ssaif}[4]{\textbf{if }{#1} \textbf{ then }{#2}\textbf{ else }{#3};{#4}}
\newcommand{\defaultssaif}{\ssaif{b}{s_0}{s_1}{\philist}}
\newcommand{\ssawhile}[3]{\textbf{while }#3;{#1} \textbf{ do } {#2}}
\newcommand{\defaultssawhile}{\ssawhile{b}{s_0}{\philist}}
\newcommand{\dunion}{\mathbin{\mathaccent\cdot\cup}}
\newcommand{\union}{\cup}
\newcommand{\storeassign}[2]{{#1} \dunion [{#2}]}
\newcommand{\leftphi}[1]{X_1 \mapsto {#1}(Y_1), \ldots}
\newcommand{\rightphi}[1]{X_1 \mapsto {#1}(Z_1), \ldots}
\newcommand{\dom}[1]{\text{dom }{#1}}
\newcommand{\lattice}{\textbf{Ltc}}
\newcommand{\lclean}{\textbf{c}}
\newcommand{\lunknown}{\textbf{u}}
\newcommand{\ltracked}{\textbf{t}}
\newcommand{\join}{\mathbin\sqcup}
% refine Join to be the unary lattice join
\let\Join\undefined
\newcommand{\Join}{\mathop\bigsqcup}
\newcommand{\restrict}[1]{\raisebox{-.5ex}{$|$}_{#1}}
\newcommand{\filter}{\Theta}

\subsection{Syntax and Semantic of dIMP}
We extend the syntax of IMP a little bit
and call the resulting language dIMP (for dataflow IMP):
\begin{align*}
    &a \Coloneqq \dots | \defaultsource\\
    &c \Coloneqq \dots | \defaultsink\\
\end{align*}
We define the set $\tilde{\textbf{Z}} =\{\flagged{} \mid n \in \textbf{Z}, f \in \{\textbf{c}, \textbf{t}\}\}$.
Stores are denoted with $\store \in \Sigma = \Loc \to \tilde{\textbf{Z}}$.
Stores are function from locations to the set of tagged integer
values.
A further restriction on valid programs is that only up to one expression
of the form $\textbf{source } a$ is allowed in a program.
This is a technical restriction, making the proof later easier.

The intuition here is that for all $n \in \textbf{Z}$, 
each value is tagged by either \textbf{c} for clean or \textbf{t} for being tracked
as having dataflow.
A tracked value originates from the source, and is preserved by value-preserving
operations (see the semantics below).
The command $\defaultsink$ is a special marker for the dataflow sink.
It aborts the program if a tracked value reaches the sink.
%This ensures termination for all programs that have dataflow.
In real programs, the dataflow source would likely be a procedure reading input,
i.e.\ from a terminal, and the dataflow sink would likely be a procedure 
printing the data to a terminal, or otherwise communicating with the outside world.


There is a new judgment of the form 
\fbox{$\bigstep{a}{\sigma}{\flagged{}}$}:
\begin{align*}
    &\bsrule{EA-Num}{}{\bigstep{\literalint}{\store}{\clean}} \qquad
    \bsrule{EA-Loc}{}{\bigstep{X}{\store}{\store(X)}}\qquad
    \bsrule{EA-Plus}
    {\bigstep{a_0}{\store}{\flagged[n_0][0]}
    \qquad \bigstep{a_1}{\store}{\flagged[n_1][1]}}
    {\bigstep{a_0+a_1}{\store}{\clean[(n_0+n_1)]}}\\
    &\bsrule{EA-Minus}
    {\bigstep{a_0}{\store}{\flagged[n_0][0]}
    \qquad \bigstep{a_1}{\store}{\flagged[n_1][1]}}
    {\bigstep{a_0-a_1}{\store}{\clean[(n_0-n_1)]}} \qquad
    \bsrule{EA-Times}
    {\bigstep{a_0}{\store}{\flagged[n_0][0]}
    \qquad \bigstep{a_1}{\store}{\flagged[n_1][1]}}
    {\bigstep{a_0 \times a_1}{\store}{\clean[(n_0 \times n_1)]}}\\
    &\bsrule{EA-Source}{\bigstep{a}{\store}{\flagged}}
    {\bigstep{\source{a}}{\store}{\tracked}}
\end{align*}

The Judgment $\langle c, \sigma \rangle \downarrow \sigma'$ is replaced by 
$\bigstep{c}{\sigma}{\excstore'}$
where $\excstore{}: (\Loc \to \StoreDomain) \cup \{\exception\}$.
The state $\exception$ indicates that the program was aborted.
Programs are aborted when a dataflow-tracked value reaches a sink.
\\
Judgement \fbox{$\bigstep{c}{\sigma}{\excstore'}$}:
\begin{align*}
    &\bsrule{EC-SinkAbrt}{\bigstep{a}{\store}{\tracked{}}}
    {\bigstep{\defaultsink}{\store}{\exception}} \qquad
    \bsrule{EC-Sink}{\bigstep{a}{\store}{\clean{}}}
    {\bigstep{\defaultsink}{\store}{\store}} \qquad
    \bsrule{EC-Skip}{}{\bigstep{\skipcmd}{\store}{\store}}\\
    &\bsrule{EC-SeqAbrt}{\bigstep{c_0}{\sigma}{\exception}}
    {\bigstep{\defaultseq}{\store}{\exception}} \qquad
    \bsrule{EC-Seq}{\bigstep{c_0}{\sigma}{\store''} \qquad \bigstep{c_1}{\store''}{\excstore'}}
    {\bigstep{\defaultseq}{\store}{\excstore'}}\\
    &\bsrule{EC-IfT}{\bigstep{b}{\store}{\btrue}\qquad \bigstep{c_0}{\store}{\excstore'}}
    {\bigstep{\defaultif}{\store}{\excstore'}} \qquad
    \bsrule{EC-IfF}{\bigstep{b}{\store}{\bfalse}\qquad \bigstep{c_1}{\store}{\excstore'}}
    {\bigstep{\defaultif}{\store}{\excstore'}}\\
    &\bsrule{EC-WhileF}{\bigstep{b}{\sigma}{\bfalse}}
    {\bigstep{\defaultwhile}{\store}{\store}} \qquad
    \bsrule{EC-WhileTAbrt}{\bigstep{b}{\sigma}{\btrue} \qquad \bigstep{c_0}{\store}{\exception}}
    {\bigstep{\defaultwhile}{\store}{\exception}}\\
    &\bsrule{EC-WhileT}{\bigstep{b}{\sigma}{\btrue} \qquad \bigstep{c_0}{\store}{\store''}\qquad
    \bigstep{\defaultwhile}{\store''}{\excstore'}}
    {\bigstep{\defaultwhile}{\store}{\excstore'}}\\
    &\bsrule{EC-Assign}{\bigstep{a}{\store}{\flagged{}}}
    {\bigstep{\defaultstore}{\store}{\store{}[X \mapsto \flagged{}]}}
\end{align*}

The judgement operations for booleans are modified to ignore the tracked-flag and work
just as in IMP. This is analoguous to how $\textsc{EA-Plus}$ etc.\ work.

\subsection{Syntax and Semantics of SSA-dIMP}
To facilitate the dataflow analysis, we describe a SSA form on dIMP with a concrete
syntax and semantics.
We do not describe how to transform a dIMP program to a SSA-dIMP program, but 
refer the reader to the literature, where different SSA construction algorithms are
described. (TODO cite). Furthermore, there are correctness proofs of SSA construction
available (TODO).

The syntax for boolean and arithmetic expressions in SSA-dIMP is the same as in dIMP.
However, the command syntax changes.
We now denote commands by $s$ (statement, or SSA-command) to highlight the differences
from the commands denoted by $c$ in dIMP.
\begin{align*}
    s \Coloneqq &\:\skipcmd \mid \defaultsink \mid \defaultstore \mid \defaultssaseq 
    \mid \defaultssaif\\
    &\mid \defaultssawhile \\
    \philist \Coloneqq &\: \defaultphilistn\\
    %\Phi_{node} \Coloneqq &\:X \coloneqq \varphi(Y, Z)
\end{align*}
At every point where $\varphi$ nodes can placed in the control flow graph
of a dIMP program, the syntax of SSA-dIMP has an explicit list of $\varphi$ nodes.

\subsubsection*{The SSA Type System}
A program in SSA-dIMP is only valid if it conforms to the SSA properties.
To enforce that, we describe a simple type system.
We require sets $\Gamma, \Delta$ of variable names that fulfill the rules below.
We then show that these sets are enough to prove that the program is indeed in SSA form.
The easiest way to get these sets is to run a SSA construction algorithm on a dIMP program.
It is a gap in the provided proofs that we do not show that every dIMP program
can be transformed in a valid SSA-dIMP program (especially, we omit showing that
$\varphi$ nodes will be placed exactly at the places they are allowed in the syntax
of SSA-dIMP).
\\
Judgement \fbox{$\typestmt{\Gamma}{a}$}:
\begin{align*}
    &\rule{SSA-Num}{}{\typestmt{\Gamma}{n}}\qquad
    \rule{SSA-Loc}{}{\typestmt{\Gamma}{X}}\text{($X \in \Gamma$)}\qquad
    \rule{SSA-Source}{\typestmt{\Gamma}{a}}{\typestmt{\Gamma}{\source{a}}}\\
    &\rule{SSA-Plus}{\typestmt{\Gamma}{a_0}\qquad\typestmt{\Gamma}{a_1}}
    {\typestmt{\Gamma}{a_0+a_1}}\quad
    \rule{SSA-Minus}{\typestmt{\Gamma}{a_0}\qquad\typestmt{\Gamma}{a_1}}
    {\typestmt{\Gamma}{a_0-a_1}}\quad
    \rule{SSA-Times}{\typestmt{\Gamma}{a_0}\qquad\typestmt{\Gamma}{a_1}}
    {\typestmt{\Gamma}{a_0 \times a_1}}
\end{align*}
Judgement \fbox{$\typestmt{\Gamma}{b}$}:
\begin{align*}
    &\rule{SSA-Eq}{\typestmt{\Gamma}{a_0}\qquad \typestmt{\Gamma}{a_1}}
    {\typestmt{\Gamma}{a_0 = a_1}}\qquad
    \rule{SSA-Leq}{\typestmt{\Gamma}{a_0}\qquad \typestmt{\Gamma}{a_1}}
    {\typestmt{\Gamma}{a_0 \leq a_1}}\qquad
    \rule{SSA-Neg}{\typestmt{\Gamma}{b}}
    {\typestmt{\Gamma}{\neg b}}\\
    &\rule{SSA-And}{\typestmt{\Gamma}{b_1}\qquad\typestmt{\Gamma}{b_2}}
    {\typestmt{\Gamma}{b_1 \land b_2}}\\
\end{align*}
Judgement \fbox{$\typestep{\Gamma;\Delta_0;\Delta_1}{\philist}{\Delta}$}:
\begin{align*}
    &\rule{SSA-$\varphi$}{}{\typestep{\Gamma;\Delta_0;\Delta_1}{\defaultphilistn}{\{X_1, \ldots, X_n\}}}\\
    &\text{(if for $i \in \{1, \ldots, n\}: X_i \notin \Gamma \land Y_i \in \Gamma \cup \Delta_0 \land Z_i \in \Gamma \cup \Delta_1
    \land \forall j \neq i: X_j \neq X_i$)}
\end{align*}
Judgement \fbox{$\typestep{\Gamma}{s}{\Delta}$}:
\begin{align*}
    &\rule{SSA-Sink}{\typestmt{\Gamma}{a}}{\typestep{\Gamma}{\sink{a}}{\emptyset}}\qquad
    \rule{SSA-Skip}{}{\typestep{\Gamma}{\skipcmd}{\emptyset}}\\
    &\rule{SSA-Assign}{\typestmt{\Gamma}{a}}{\typestep{\Gamma}{\defaultstore}{\{X\}}} \text{($X \notin \Gamma$)}\\
    &\rule{SSA-Seq}{\typestep{\Gamma}{s_0}{\Delta_0}\qquad
    \typestep{\Gamma \cup \Delta_0}{s_1}{\Delta_1}}{\typestep{\Gamma}{\defaultssaseq}{\Delta_0 \cup \Delta_1}}\\
    &\rule{SSA-If}{\typestmt{\Gamma}{b}\qquad\typestep{\Gamma}{s_0}{\Delta_0}\qquad \typestep{\Gamma}{s_1}{\Delta_1}\qquad
    \typestep{\Gamma;\Delta_0;\Delta_1}{\philist}{\Delta}}
    {\typestep{\Gamma}{\defaultssaif}{\Delta}}\\
    &\rule{SSA-While}{\typestep{\Gamma;\emptyset;\Delta_1}{\philist}{\Delta}\qquad
    \typestmt{\Gamma \cup \Delta}{b}\qquad\typestep{\Gamma \cup \Delta}{s_0}{\Delta_1}}
    {\typestep{\Gamma}{\defaultssawhile}{\Delta}}
\end{align*}

Note that by this definition, the first argument of $\varphi$ nodes for \textbf{if} commands
corresponds to the variable after executing the \btrue{} branch, and the second argument to that
of the variable after executing the \bfalse{} branch.
For \textbf{while} commands, the first argument to the $\varphi$ node corresponds to the value
before executing $s_0$ the first time, and the second argument corresponds to the value 
after executing the loop body.
The sets $\Gamma$ and $\Delta$ are natural outputs of an algorithm that converts a 
dIMP program into SSA-dIMP form.
They prove that a (not necessarily minimal) SSA form was indeed achieved.
TODO something about use of initial values, as they cannot have a definition

\subsubsection*{The Semantics of SSA-dIMP}
Stores are now partial functions $\store : \Sigma \partialf \Loc$ to indicate that
variables have to be defined before they can be read.
%Furthermore, when updating a store, we now use the syntax 
%$\store \dunion [X \mapsto \flagged{}]$ to indicate that the store $\store$ did not
%contain the variable $X$ before.

The judgment for booleans and arithmetic expressions does not change.
As before, we use $\excstore{}$ to denote partial functions
$\excstore{}: \Loc (\partialf \StoreDomain) \cup \{\exception\}$.
%where the evaluation of $\philist$ 
%is combined with the variables in the store $\sigma$.
% TODO cleanup
For $\varphi$ nodes, we introduce to judgements - one that evaluates them to the first argument,
and one that evalutes them to the second argument.
Both judgements are provided with a filter $\filter$ that specifies which variables 
to keep from the outer store.
\\
Judgment \fbox{$\bigsteppl{\philist}{\filter}{\store}{\store'}$}:
\begin{align*}
    &\bsrule{E$\Phi_1$-Assign}{}
    {\bigsteppl{\defaultphilistn}{\filter}{\store}{\storeassign{\store\restrict{\filter}}{X_1 \mapsto \store(Y_1),\ldots X_n \mapsto \store(Y_n)}}}\\
\end{align*}
Judgment \fbox{$\bigsteppr{\philist}{\filter}{\store}{\store'}$}:
\begin{align*}
    &\bsrule{E$\Phi_2$-Assign}{}
    {\bigsteppr{\defaultphilistn}{\filter}{\store}{\storeassign{\store\restrict{\filter}}{X_1 \mapsto \store(Z_1),\ldots X_n \mapsto \store(Z_n)}}}\\
\end{align*}

In order to correctly model the execution of $\varphi$ nodes for \textbf{while} commands,
a second judgment is set up.
The regular command judmenent only populates the variables defined by the $\varphi$ nodes
and then defers to a special while-command-judgement that evaluates all loop executions,
evaluating the $\varphi$ nodes with the store after the loop body execution.

With $\excstore{}: (\Loc \partialf \StoreDomain) \union \{\exception\}$ we have the following rules for the
 judgment \fbox{$\bigstep{c}{\store}{\excstore{}}$}:
\begin{align*}
    &\bsrule{EC-SinkAbrt}{\bigstep{a}{\store}{\tracked{}}}
    {\bigstep{\defaultsink}{\store}{\exception}} \qquad
    \bsrule{EC-Sink}{\bigstep{a}{\store}{\clean{}}}
    {\bigstep{\defaultsink}{\store}{\store}} \qquad
    \bsrule{EC-Skip}{}{\bigstep{\skipcmd}{\store}{\store}}\\
    &\bsrule{EC-Seq}{\bigstep{s_0}{\sigma}{\store''} \qquad \bigstep{s_1}{\store''}{\excstore'}}
    {\bigstep{\defaultssaseq}{\store}{\excstore'}}\qquad
    \bsrule{EC-SeqAbrt}{\bigstep{s_0}{\sigma}{\exception}}
    {\bigstep{\defaultssaseq}{\store}{\exception}} \\
    &\bsrule{EC-IfTAbrt}{\bigstep{b}{\store}{\btrue}\qquad \bigstep{s_0}{\store}{\exception}}
    {\bigstep{\defaultssaif}{\store}{\exception}}\\
    &\bsrule{EC-IfFAbrt}{\bigstep{b}{\store}{\bfalse}\qquad \bigstep{s_1}{\store}{\exception}}
    {\bigstep{\defaultssaif}{\store}{\exception}}\\
    &\bsrule{EC-Assign}{\bigstep{a}{\store}{\flagged{}}}
    {\bigstep{\defaultstore}{\store}{\storeassign{\store}{X \mapsto \flagged{}}}}\\
    &\bsrule{EC-IfT}{\bigstep{b}{\store}{\btrue}\qquad \bigstep{s_0}{\store}{\store''}
    \qquad \bigsteppl{\philist}{\dom\store}{\store''}{\store'}}
    {\bigstep{\defaultssaif}{\store}{\store'}}\\
    &\bsrule{EC-IfF}{\bigstep{b}{\store}{\bfalse}\qquad \bigstep{s_1}{\store}{\store''}
    \qquad \bigsteppr{\philist}{\dom\store}{\store''}{\store'}}
    {\bigstep{\defaultssaif}{\store}{\store'}}\\
    &\bsrule{EC-While}{\bigsteppl{\philist}{\dom\store}{\store}{\store''} \qquad
    \bigstepw{\defaultssawhile}{\dom\store}{\store''}{\excstore'}}
    {\bigstep{\defaultssawhile}{\store}{\excstore'}}\\
\end{align*}

For while loops, we introduce a special judgment of the form \fbox{$\bigstepw{c}{\filter}{\store}{\excstore'{}}$}:
\begin{align*}
    &\bsrule{EW-WhileF}{\bigstep{b}{\store}{\bfalse}}
    {\bigstepw{\defaultssawhile}{\filter}{\store}{\store}}\qquad\\
    &\bsrule{EW-WhileTAbrt}{\bigstep{b}{\store}{\btrue} \qquad 
    \bigstep{s_0}{\store}{\exception}}
    {\bigstepw{\defaultssawhile}{\filter}{\store}{\exception}}\\
    &\bsrule{EW-WhileT}{\bigstep{b}{\store}{\btrue} \enskip
    \bigstep{s_0}{\store}{\store''} \enskip
    \bigsteppr{\philist}{\filter}{\store''}{\store'''} \enskip
    \bigstepw{\defaultssawhile}{\filter}{\store'''}{\excstore'}}
    {\bigstepw{\defaultssawhile}{\filter}{\store}{\excstore'}}
\end{align*}
\begin{conjecture}
    We conjecture that for every dIMP program $c$ with initial store $\initialstore$
    such that $\bigstep{c}{\initialstore}{\exception}$ there exists a equivalent program
    $s$ in SSA-dIMP with sets $\Gamma, \Delta$ and an initial store $\initialstore_0$ such that
     $\bigstep{s}{\initialstore_0}{\exception}$ with
    $\dom{\initialstore_0} = \Gamma$ and $\forall X \in \Gamma: \initialstore_0(X) = \initialstore(X)$.
\end{conjecture}

We state that a SSA-dIMP program together with the SSA type derivation
is in fact in SSA form - each variable is defined only once.
Furthermore, the structure of the bigstep derivation trees imply that 
for every bigstep derivation, all variables are defined before they are used.
Proofs are omitted, as we prove these theorems in greater generality later.

\begin{theorem}
    %\label{thm:gamma-delta-disjoint}
    If $\typestep{\Gamma}{s}{\Delta}$ holds, then $\Gamma \cap \Delta = \emptyset$.
\end{theorem}

\begin{theorem}
    If $\typestep{\Gamma}{s}{\Delta}$, $\text{dom } \store = \Gamma$ and
    $\bigstep{s}{\store}{\store'}$, then $\store' = \store \dunion \store_0$
    and $\dom{\store_0} = \Delta$.
\end{theorem}

\subsection{Definition of Dataflow}
\begin{definition}[Program]
    A \emph{program} in dIMP is a command $c$.
    Complex programs are expressed by using the recursive nature of
    the definition of commands.
    Any program in dIMP can be transformed to be a program $s$ in SSA-dIMP with associated
    sets $\Gamma, \Delta$.
\end{definition}

\begin{definition}[Initial Store]
    An \emph{initial store} is a store $\initialstore$ s.t.\ 
    $\forall X: \exists n: \initialstore(X) = \clean[n]$.
    This means that in an initial store all values are flagged as being clean.
    We will implicitly denote inital stores by $\initialstore$.
\end{definition}

\begin{definition}[Dataflow]
    A tuple $(s, \initialstore, \Gamma, \Delta)$ of a program $s$ and initial store $\initialstore{}$ 
    with $\dom{\initialstore{}} = \Gamma$
    has \emph{dataflow from the source to a sink} if
    $\bigstep{s}{\initialstore{}}{\exception}$ holds.
    This means that the program aborts.
\end{definition}

\begin{definition}[Dataflow Algorithm]
    A \emph{dataflow algorithm} $\A(s, \Gamma, \Delta)$ computes, given a program $s$
    and a SSA type derivation $\typestep{\Gamma}{s}{\Delta}$,
    if there exists an initial store $\initialstore{}$ 
    such that $(s, \initialstore, \Gamma, \Delta)$ has dataflow from the source to a sink.
    $\A(s, \Gamma, \Delta) \in \{\text{HAS\_FLOW}, \text{NO\_FLOW}, \text{UNKOWN}\}$.
    TODO: Do we really want unkown here? HAS FLOW is no guarantee, as dead code/unreachable paths 
    are still reported as HAS FLOW, not as UNKOWN
%    \text{HAS\_FLOW} indicates that it is ver
\end{definition}

\begin{definition}[Soundness]
    A dataflow algorithm is \emph{sound} if for any tuple $(s, \initialstore, \Gamma, \Delta)$ that
    has dataflow it holds that $\A(s, \Gamma, \Delta) = \text{HAS\_FLOW}$ or
    $\A(s, \Gamma, \Delta) = \text{UNKNOWN}$.
\end{definition}

\begin{definition}[Completeness]
    A dataflow algorithm is \emph{complete} if $\A(s, \Gamma, \Delta) = \text{HAS\_FLOW}$
    implies that there exists an initial store $\initialstore$
     such that $(s, \initialstore, \Gamma, \Delta)$ has dataflow.
\end{definition}
\begin{definition}[False Positive]
    A program $s$ for which there exists no initial store $\initialstore$ such that 
    $(s, \initialstore, \Gamma, \Delta)$ has dataflow, but for which $\A(s, \Gamma, \Delta) = \text{HAS\_FLOW}$
    or $\A(s, \Gamma, \Delta) = \text{UNKOWN}$ holds
    is called a \emph{false positive} of the algorithm.
\end{definition}
\begin{remark}
    In general, it is impossible to construct a dataflow algorithm that is both 
    sound and complete.
    In practice, a dataflow algorithm may be neither sound nor complete.
    However, in the theoretical setting of this chapter, we are interested in 
    sound dataflow algorithms.
    The \emph{trivially sound dataflow algorithm} $\A_0(s, \Gamma, \Delta) = \text{UNKOWN}$ 
    is sound by definition, but not very interesting.
    We will not consider it further, but it is interesting to keep in mind,
    because it shows that just proving that a dataflow algorithm is sound does not
    mean it is useful.    
\end{remark}

\subsection{A General Setting For Flow Analysis}
In this section, we extend the type system presented for SSA to be viable as a
general-purpose constraint system.
This constraint system can then be solved via fixed-point iteration.
The system is designed in a way that it can be easily adapted to different analyses.
We instantiate this system to determine if programs have dataflow.

Let $\lattice$ be a poset.
Let $\Join: \lattice \times \lattice \partialf \lattice$ be the (partially defined)
join operator on the poset.
We require that its domain is maximal, i.e. if $L_1, L_2 \in \lattice$ have a least upper
bound, it is $L_1 \join L_2$.
Let $\Gamma, \Delta: \Loc \partialf \lattice$.

For dataflow analysis, we have $\lattice = \{\lclean, \ltracked, \lunknown\}$.
Every variable encountered in the program is marked with a value in \lattice.
Thus, it is either marked with \lclean{} (the variable
is clean, i.e.\ does not contain a value originating from a dataflow source), \lunknown{}
(it is unknown whether the variable contains a value originating from a source) or \ltracked{}
(the variable contains a tracked value from a dataflow source).
We define the following poset structure on it:
TODO nice picture, \lunknown{} is the top element, no bottom element.
Then the join operator is defined on the whole poset.

We introduce the following judgements.
\\
Judgement \fbox{$\typestep{\Gamma}{a}{L}$}:
\begin{align*}
    &\rule{DF-Num}{}{\typestep{\Gamma}{n}{\lclean}}\qquad
    \rule{DF-Loc}{}{\typestep{\Gamma}{X}{\Gamma(X)}}\qquad
    \rule{DF-Source}{\typestep{\Gamma}{a}{L}}
    {\typestep{\Gamma}{\source{a}}{\ltracked}}\\
    &\rule{DF-Plus}{\typestep{\Gamma}{a_0}{L_0}\qquad\typestep{\Gamma}{a_1}{L_1}}
    {\typestep{\Gamma}{a_0+a_1}{\lclean}}\qquad
    \rule{DF-Minus}{\typestep{\Gamma}{a_0}{L_0}\qquad\typestep{\Gamma}{a_1}{L_1}}
    {\typestep{\Gamma}{a_0-a_1}{\lclean}}\\
    &\rule{DF-Times}{\typestep{\Gamma}{a_0}{L_0}\qquad\typestep{\Gamma}{a_1}{L_1}}
    {\typestep{\Gamma}{a_0 \times a_1}{\lclean}}
\end{align*}
Judgement \fbox{$\typestmt{\Gamma}{b}$}:
\begin{align*}
    &\rule{DF-Eq}{\typestep{\Gamma}{a_0}{L_0}\qquad \typestep{\Gamma}{a_1}{L_1}}
    {\typestmt{\Gamma}{a_0 = a_1}}\qquad
    \rule{DF-Leq}{\typestep{\Gamma}{a_0}{L_0}\qquad \typestep{\Gamma}{a_1}{L_1}}
    {\typestmt{\Gamma}{a_0 \leq a_1}}\qquad
    \rule{DF-Neg}{\typestmt{\Gamma}{b}}
    {\typestmt{\Gamma}{\neg b}}\\
    &\rule{DF-And}{\typestmt{\Gamma}{b_1}\qquad\typestmt{\Gamma}{b_2}}
    {\typestmt{\Gamma}{b_1 \land b_2}}\\
\end{align*}
Judgement \fbox{$\typestep{\Gamma;\Delta_0;\Delta_1}{\philist}{\Delta}$}:
\begin{align*}
    &\rule{DF-$\varphi$}{}{\typestep{\Gamma;\Delta_0;\Delta_1}{\defaultphilistn}{[X_1 \mapsto L_1, \ldots, X_n \mapsto L_n]}}\\
    &\text{(if for $i \in \{1, \ldots, n\}: X_i \notin \dom\Gamma \land L_i = (\Gamma \dunion \Delta_0)(Y_i) \join (\Gamma \dunion \Delta_1)(Z_i)
    \land \forall j \neq i: X_j \neq X_i$)}
\end{align*}
Note that this implies that this rule is only applicable if $Y_i$, $Z_i$ exist in the respective
domains of the partial functions, and if the join exists as well.\\
Judgement \fbox{$\typestep{\Gamma}{s}{\Delta}$}:
\begin{align*}
    &\rule{DF-Sink}{\typestep{\Gamma}{a}{L}}{\typestep{\Gamma}{\sink{a}}{\emptyset}}\qquad
    \rule{DF-Skip}{}{\typestep{\Gamma}{\skipcmd}{\emptyset}}\\
    &\rule{DF-Assign}{\typestep{\Gamma}{a}{L}}
    {\typestep{\Gamma}{\defaultstore}{[X \mapsto L]}} \text{($X \notin \dom\Gamma$)}\\
    &\rule{DF-Seq}{\typestep{\Gamma}{s_0}{\Delta_0}\qquad
    \typestep{\Gamma \cup \Delta_0}{s_1}{\Delta_1}}{\typestep{\Gamma}{\defaultssaseq}{\Delta_0 \cup \Delta_1}}\\
    &\rule{DF-If}{\typestmt{\Gamma}{b}\qquad\typestep{\Gamma}{s_0}{\Delta_0}\qquad \typestep{\Gamma}{s_1}{\Delta_1}\qquad
    \typestep{\Gamma;\Delta_0;\Delta_1}{\philist}{\Delta}}
    {\typestep{\Gamma}{\defaultssaif}{\Delta}}\\
    &\rule{DF-While}{\typestep{\Gamma;\emptyset;\Delta_1}{\philist}{\Delta}\qquad
    \typestmt{\Gamma \cup \Delta}{b}\qquad\typestep{\Gamma \cup \Delta}{s_0}{\Delta_1}}
    {\typestep{\Gamma}{\defaultssawhile}{\Delta}}
\end{align*}

\begin{definition}[Store-Matching]
    A store $\store$ \emph{matches a description} $\Gamma: \Loc \partialf \lattice$ if it holds that 
    $\dom\store = \dom\Gamma$ and
    \begin{align*}
        \forall X: \exists n \in \Z: (\Gamma(X) = \ltracked \implies \store(X) = \tracked)
        \land (\Gamma(X) = \lclean \implies \store(X) = \clean)
    \end{align*}
\end{definition}

First, we justify why the semantics contains disjoint unions when updating stores.
\begin{theorem}
    \label{thm:gamma-delta-disjoint}
    If $\typestep{\Gamma}{s}{\Delta}$ holds, then $\dom\Gamma \cap \dom\Delta = \emptyset$.
\end{theorem}

Then we prove some lemmas needed to establish the key properties of the semantics
and the dataflow rules.
\begin{lemma}
    \label{lem:gamma-arithm}
    Let $\E$ be the derivation of $\bigstep{a}{\sigma}{\flagged{}}$.
    If $\typestep{\Gamma}{a}{L}$ and $\store$ matches $\Gamma$, then 
    for all subderivations $\bigstep{a_0}{\sigma_0}{\flagged{}}$ in $\E$
    there exists a derivation
    $\typestep{\Gamma_0}{a_0}{L_0}$ such that $\Gamma_0$ matches $\sigma_0$
    and $L$ is either $\lunknown$ or correctly describes the flag of $\flagged{}$.
\end{lemma}
\begin{lemma}
    \label{lem:gamma-bool}
    Let $\E$ be the derivation of $\bigstep{b}{\sigma}{t}$.
    If $\typestmt{\Gamma}{b}$ and $\store$ matches $\Gamma$, then 
    for all subderivations $\bigstep{b_0}{\sigma_0}{t}$ in $\E$
    there exists a derivation
    $\typestmt{\Gamma_0}{b_0}$ such that $\Gamma_0$ matches $\sigma_0$,
    and for all derivations $\bigstep{a}{\store_1}{\flagged{}}$ in $\E$
    there exists a derivation $\typestep{\Gamma_1}{a}{L}$ such that $\Gamma_1$
    matches $\store_1$.
\end{lemma}

For the dataflow rules, there are theorems akin the preservation and progress results
proven about type systems.
These are then used to derive a general soundness result about using the dataflow rules
to detect the possiblity of dataflow.
Based on that, an algorithm is presented and proven to be sound.

\begin{lemma}[Preservation-ish $\Phi$]
    \label{thm:preservation-phi}
    Let $\bigsteppl{\Phi}{\Theta}{\sigma''}{\sigma'}$ (or $\bigsteppr{\Phi}{\Theta}{\sigma''}{\sigma'}$),
    such that $\store'' = \store \dunion \store_0''\dunion \store{\_}$, $\store$ matches $\Gamma$, 
    $\store_0''$ matches $\Delta_1$ (or $\Delta_2$) and $\Theta = \dom\store$.
    Let $\typestep{\Gamma;\Delta_0;\Delta_1}{\Phi}{\Delta}$ by the DF rules.
    Then we have that $\store' = \store \dunion \store_0$,
    and $\store_0$ matches the description $\Delta$.
\end{lemma}

\begin{theorem}[Preservation-ish]
    \label{thm:preservation}
    Let $\bigstep{s}{\store}{\store'}$ by $\E$, $\store$ matches the description $\Gamma$,
    and let $\typestep{\Gamma}{s}{\Delta}$ by $\D$ and the DF rules.
    Then we have that $\store' = \store \dunion \store_0$,
    and $\store_0$ matches the description $\Delta$.
\end{theorem}
\begin{proof}
    We prove the theorem by induction over the derivation $\E$.\\
    \textbf{Case 1:}
    Skip\\
    \textbf{Case 2:}
    Sink\\
    \textbf{Case 3:}
    \begin{align*}
        &\E = \bsrule{EC-Seq}{\overset{\E_0}{\bigstep{s_0}{\sigma}{\store''}}
         \qquad \overset{\E_1}{\bigstep{s_1}{\store''}{\store'}}}
        {\bigstep{\defaultssaseq}{\store}{\store'}}\\
        &\D = \rule{DF-Seq}{\overset{\D_0}{\typestep{\Gamma}{s_0}{\Delta_0}}\qquad
        \overset{\D_1}{\typestep{\Gamma \cup \Delta_0}{s_1}{\Delta_1}}}
        {\typestep{\Gamma}{\defaultssaseq}{\Delta_0 \cup \Delta_1}}
    \end{align*}
    By assumption we have that $\Gamma$ matches $\store$.
    Thus, we can apply the IH on $\E_0$ with $\D_0$.
    Thus $\store'' = \store \dunion \store''_0$ and $\store''_0$ matches $\Delta_0$.
    Thus, $\Gamma \union \Delta_0$ matches $\store''$.
    Thus, we apply the IH on $\E_1$ with $\D_1$, and we get that
    $\store' = \store'' \dunion \store'_0$ and $\Delta_1$ matches $\store'_0$.
    Then, we have $\store' = \store \dunion \store''_0 \dunion \store'_0$
    and we can set $\store_0 = \store''_0 \dunion \store'_0$, and we obviously 
    have that $\store_0$ matches $\Delta_0 \union \Delta_1$.\\
    \textbf{Case 4:}
    \begin{align*}
        &\E = \bsrule{EC-IfT}{
        \overset{}{\bigstep{b}{\store}{\btrue}}\qquad 
        \overset{\E_0}{\bigstep{s_0}{\store}{\store''}}
        \qquad 
        \overset{\E_1}{\bigsteppl{\philist}{\dom\store}{\store''}{\store'}}}
        {\bigstep{\defaultssaif}{\store}{\store'}}\\
        &\D = \rule{DF-If}{
        \overset{}{\typestmt{\Gamma}{b}}\qquad
        \overset{\D_0}{\typestep{\Gamma}{s_0}{\Delta_0}}\qquad \typestep{\Gamma}{s_1}{\Delta_1}\qquad
        \overset{\D_1}{\typestep{\Gamma;\Delta_0;\Delta_1}{\philist}{\Delta}}}
        {\typestep{\Gamma}{\defaultssaif}{\Delta}}
    \end{align*}
    By IH on $\E_0$ with $\D_0$, we get that $\store'' = \store \dunion \store''_0$ and 
    $\store''_0$ matches $\Delta_0$.
    The result then follows from~\autoref{thm:preservation-phi} on $\E_0$ with $\D_0$.\\
    \textbf{Case 5:}
    $\E$ uses \textsc{EC-IfF}: analoguous.\\
    \textbf{Case 6:}
    \begin{align*}
        &\E = \bsrule{EC-Assign}{\overset{\E_0}{\bigstep{a}{\store}{\flagged{}}}}
        {\bigstep{\defaultstore}{\store}{\storeassign{\store}{X \mapsto \flagged{}}}}\\
        &\D = \rule{DF-Assign}{\overset{\D_0}{\typestep{\Gamma}{a}{L}}}
        {\typestep{\Gamma}{\defaultstore}{[X \mapsto L]}}
    \end{align*}
    We apply~\autoref{lem:gamma-arithm} on $\E_0$ with $\D_0$,
    and as $L$ matches $\flagged{}$, $\Delta = [X \mapsto L]$ matches the store
    $[X \mapsto \flagged{}]$.
    ~\autoref{thm:gamma-delta-disjoint} implies that the union in the \textsc{EC-Assign}
    rule is actually disjoint.
    \\
    \textbf{Case 7:}\\
    \begin{align*}
        &\E = \bsrule{EC-While}{\overset{\E_0}{\bigsteppl{\philist}{\dom\store}{\store}{\store''}}\qquad
        \overset{\E_2}{\bigstepw{\defaultssawhile}{\dom\store}{\store''}{\excstore'}}}
        {\bigstep{\defaultssawhile}{\store}{\store'}}\\
        &\D = \rule{DF-While}{\overset{\D_0}{\typestep{\Gamma;\emptyset;\Delta_1}{\philist}{\Delta}}\qquad
        \overset{\D_1}{\typestmt{\Gamma \cup \Delta}{b}}\qquad
        \overset{\D_2}{\typestep{\Gamma \cup \Delta}{s_0}{\Delta_1}}}
        {\typestep{\Gamma}{\defaultssawhile}{\Delta}}
    \end{align*}
    By applying~\autoref{thm:preservation-phi} on $\E_0$ with $\D_0$, we get that
    $\store'' = \store \dunion \store_0$, $\Delta$ matches $\store_0$.
    Thus $\Gamma \union \Delta$ matches $\store''$.
    We prove the statement by an inner induction over the while derivation $\E^w$:
    \begin{claim}
        Let $\bigstepw{\defaultwhile}{\filter}{\store_w}{\store_w'}$ by $\E^w$,
         $\store_w = \store_w^0 \dunion \store_w^1$
        such that $\store_w^0$ matches $\Gamma$, $\Theta = \dom\store^0_w$ and $\store_w^1$ matches $\Delta$,
        and let $\typestep{\Gamma}{\defaultwhile}{\Delta}$ by $\D$ and the DF rules.
        Then we have that $\store_w' = \store_w^0 \dunion \store_0$,
        and $\store_0$ matches the description $\Delta$.
    \end{claim}
    \begin{claimproof}
        \emph{Subcase 1:}
        \begin{align*}
            \E^w = \bsrule{EW-WhileF}{
            \overset{}{\bigstep{b}{\store_w}{\bfalse}}}
            {\bigstepw{\defaultssawhile}{\filter}{\store_w}{\store_w}}
        \end{align*}
        Trivial, $\store_0 = \store_w^1$.\\
        \emph{Subcase 2:}
        \begin{align*}
            \E^w = \bsrule{EW-WhileT}{\overset{}{\bigstep{b}{\store_w}{\btrue}} \enskip
            \overset{\E^w_0}{\bigstep{s_0}{\store_w}{\store''}} \enskip
            \overset{\E^w_1}{\bigsteppr{\philist}{\filter}{\store''}{\store'''}} \enskip
            \overset{\E^w_2}{\bigstepw{\defaultssawhile}{\filter}{\store'''}{\excstore'}}}
            {\bigstepw{\defaultssawhile}{\filter}{\store_w}{\store_w'}}
        \end{align*}
        By the outer IH on $\E^w_0$ with $\D_2$, we get that
        $\sigma'' = \sigma_w \dunion \sigma_w'' = \sigma_w^0 \dunion \sigma_w^1 \dunion \sigma_w''$
        and $\Delta_1$ matches $\sigma_w''$.
        By~\autoref{thm:preservation-phi} we get that $\store''' = \store_w^0 \dunion \store_0'''$ and
        $\store_0'''$ matches $\Delta$.
        With that we can apply the inner induction on $\E^2_w$ with $\D$ to get the result on $\sigma_w'$.
    \end{claimproof}
    We finish the proof by applying the claim on $\E^2$ with $\D$.
\end{proof}



\begin{theorem}[Progress-Ish]
    \label{thm:progress}
    Let $\E$ be the derivation tree of $\bigstep{s}{\store}{\store'}$.
    Let $\Gamma$ be a description that is matching $\store$ and
    $\D$ the derivation $\typestep{\Gamma}{s}{\Delta}$.
    Then for all subderivations $\E_s$ of form $\bigstep{s_s}{\store_s}{\store'_s}$ in $\E$
    we have that there exists $\Gamma_s$ matching $\store_s$
    in the subderivation $\D_s$ of $\typestep{\Gamma_s}{s_s}{\Delta_s}$ in $\D$.
    For all subderivations $\E_a$ of form $\bigstep{a}{\store_a}{\flagged{}}$ in $\E$
    we have that there exists $\Gamma_a$ matching $\store_a$
    in the subderivation $\D$ of $\typestep{\Gamma_a}{a}{L}$ in $\D_a$.
    For all subderivations $\E_b$ of form $\bigstep{b}{\store_b}{t}$ in $\E$
    we have that there exists $\Gamma_b$ matching $\store_b$
    in the subderivation $\D$ of $\typestmt{\Gamma_b}{b}$ in $\D_b$.
\end{theorem}
\begin{proof}
    Proof by induction over the derivation $\E$.\\
    \textbf{Case 1:}
    Skip\\
    \textbf{Case 2:}
    Sink\\
    \textbf{Case 3:}
    \begin{align*}
        &\E = \bsrule{EC-Seq}{\overset{\E_0}{\bigstep{s_0}{\sigma}{\store''}}
         \qquad \overset{\E_1}{\bigstep{s_1}{\store''}{\store'}}}
        {\bigstep{\defaultssaseq}{\store}{\store'}}\\
        &\D = \rule{DF-Seq}{\overset{\D_0}{\typestep{\Gamma}{s_0}{\Delta_0}}\qquad
        \overset{\D_1}{\typestep{\Gamma \cup \Delta_0}{s_1}{\Delta_1}}}
        {\typestep{\Gamma}{\defaultssaseq}{\Delta_0 \cup \Delta_1}}
    \end{align*}
    By assumption we have that $\Gamma$ matches $\store$.
    Thus, we can apply the IH on $\E_0$ with $\D_0$.
    By~\autoref{thm:preservation} we get that $\store'' = \store \dunion \store_0$
    and $\Delta_0$ matches $\store_0$.
    Thus, $\Gamma \union \Delta_0$ matches $\store''$
    and we can apply the IH on $\E_1$ with $\D_1$.\\
    \textbf{Case 4:}
    \begin{align*}
        &\E = \bsrule{EC-IfT}{
        \overset{\E_0}{\bigstep{b}{\store}{\btrue}}\qquad 
        \overset{\E_1}{\bigstep{s_0}{\store}{\store''}}
        \qquad \bigsteppl{\philist}{\dom\store}{\store''}{\store'}}
        {\bigstep{\defaultssaif}{\store}{\store'}}\\
        &\D = \rule{DF-If}{
        \overset{\D_0}{\typestmt{\Gamma}{b}}\qquad
        \overset{\D_1}{\typestep{\Gamma}{s_0}{\Delta_0}}\qquad \typestep{\Gamma}{s_1}{\Delta_1}\qquad
        \typestep{\Gamma;\Delta_0;\Delta_1}{\philist}{\Delta}}
        {\typestep{\Gamma}{\defaultssaif}{\Delta}}
    \end{align*}
    Apply~\autoref{lem:gamma-bool} on $\E_0$ with $\D_0$ and the IH on $\E_1$ with $\D_1$.\\
    \textbf{Case 5:}
    $\E$ uses \textsc{EC-IfF}: analoguous.\\
    \textbf{Case 6:}
    \begin{align*}
        &\E = \bsrule{EC-Assign}{\overset{\E_0}{\bigstep{a}{\store}{\flagged{}}}}
        {\bigstep{\defaultstore}{\store}{{\storeassign{\store}{X \mapsto \flagged{}}}}}\\
        &\D = \rule{DF-Assign}{\overset{\D_0}{\typestep{\Gamma}{a}{L}}}
        {\typestep{\Gamma}{\defaultstore}{[X \mapsto L]}}
    \end{align*}
    Apply~\autoref{lem:gamma-arithm} on $\E_0$ with $\D_0$.\\
    \textbf{Case 7:}\\
    \begin{align*}
        &\E = \bsrule{EC-While}{\overset{\E_0}{\bigsteppl{\philist}{\dom\store}{\store}{\store''}}\qquad
        \overset{\E_2}{\bigstepw{\defaultssawhile}{\dom\store}{\store''}{\excstore'}}}
        {\bigstep{\defaultssawhile}{\store}{\store'}}\\
        &\D = \rule{DF-While}{\overset{\D_0}{\typestep{\Gamma;\emptyset;\Delta_1}{\philist}{\Delta}}\qquad
        \overset{\D_1}{\typestmt{\Gamma \cup \Delta}{b}}\qquad
        \overset{\D_2}{\typestep{\Gamma \cup \Delta}{s_0}{\Delta_1}}}
        {\typestep{\Gamma}{\defaultssawhile}{\Delta}}
    \end{align*}
    By applying~\autoref{thm:preservation-phi} on $\E_0$ with $\D_0$, we get that
    $\Gamma \union \Delta$ matches $\store''$.
    We prove the statement by an inner induction over the while derivation $\E^w$:
    \begin{claim}
        Assume that $\Gamma \union \Delta$ match $\store_w$, and that $\dom\Gamma = \Theta$.
        Then we have that in all sub-derivations of $\E^w$, there exists $\Gamma_w, \Delta_w$ such that 
        in $\bigstep{s_w}{\store_w}{\store_w'}$, $\bigstep{a_w}{\store_w}{\flagged{}}$ and 
        $\bigstep{b_w}{\store_w}{t}$    
        with respective derivations 
        $\typestep{\Gamma_w}{s_w}{\Delta_w}$, $\typestep{\Gamma_w}{a_w}{L}$ and $\typestmt{\Gamma_w}{b_w}$
        such that $\Gamma_w$ matches $\store_w$.    
    \end{claim}
    \begin{claimproof}
        \emph{Subcase 1:}
        \begin{align*}
            \E^w = \bsrule{EW-WhileF}{
            \overset{\E^w_0}{\bigstep{b}{\store_w}{\bfalse}}}
            {\bigstepw{\defaultssawhile}{\filter}{\store_w}{\store_w}}
        \end{align*}
        Then we apply~\autoref{lem:gamma-bool} on $\E^w_0$ with $\D_1$.\\
        \emph{Subcase 2:}
        \begin{align*}
            \E^w = \bsrule{EW-WhileT}{\overset{\E^w_0}{\bigstep{b}{\store_w}{\btrue}} \enskip
            \overset{\E^w_1}{\bigstep{s_0}{\store_w}{\store''}} \enskip
            \overset{\E^w_2}{\bigsteppr{\philist}{\filter}{\store''}{\store'''}} \enskip
            \overset{\E^w_3}{\bigstepw{\defaultssawhile}{\filter}{\store'''}{\excstore'}}}
            {\bigstepw{\defaultssawhile}{\filter}{\store_w}{\store_w'}}
        \end{align*}
        Apply~\autoref{lem:gamma-bool} on $\E_0^w$ with $\D_1$
        and the outer IH on $\E^w_1$ with $\D_2$.
        Furthermore, by~\autoref{thm:preservation} on $\E^w_1$ with $\D_2$ we get that 
        $\store'' = \store_w \dunion \store''_w$ and $\store''_w$ is matched by $\Delta_1$.
        Thus, by~\autoref{thm:preservation-phi} on $\E_2^w$ with $\D_0$ we get that $\Gamma \union \Delta$
        matches $\store'''$, and we can apply the inner IH on $\E^w_3$.
    \end{claimproof}
    We finish proving the case by applying the claim on $\E_2$.
\end{proof}

We also have the following (general) soundness property of the dataflow analysis:
\begin{theorem}[Soundness of the DF rules]
    Let $(s, \Gamma_{ssa}, \Delta_{ssa})$ be a program in SSA form and let $\store_s$ be a store
    with $\dom\store_s = \Gamma_{ssa}$.
    Let $\E_s$ be the bigstep derivation of $\bigstep{s}{\store_s}{\excstore{}_s}$.
    Let $\Gamma_s: \Gamma_{ssa} \partialf \lattice$ be defined by
    \begin{align*}
        \Gamma_s(X) \mapsto \begin{cases}
            \lclean & \text{if $\exists n \in \Z: \store_s(X) = \clean$}\\
            \ltracked & \text{if $\exists n \in \Z: \store_s(X) = \tracked{}$}\\
        \end{cases}
    \end{align*}
    If $\excstore{}' = \exception$, then
    the derivation tree $\D_s$ of $\typestep{\Gamma_{s}}{s}{\Delta_s}$ using the DF ruleset
    contains at least one sub-derivation of the form
    \begin{equation*}
        \D_t = \rule{DF-Sink}{\typestep{\Gamma_t}{a_t}{L_t}}{\typestep{\Gamma_t}{\sink{a_t}}{\emptyset}}
    \end{equation*}
    where $L_t = \lunknown$ or $L_t = \ltracked$.
\end{theorem}
\begin{proof}
    If $\excstore{}' = \exception$, then there exists a sub-command $\defaultsink$ of $s$
    such that there exists a store $\store$, $\Gamma$, $L \in \lattice$ and a sub-derivation tree $\E$ of $\E_s$
    such that
    \begin{align*}
        \E = \bsrule{EC-SinkAbrt}{\overset{\E_0}{\bigstep{a}{\store}{\tracked{}}}}
        {\bigstep{\defaultsink}{\store}{\exception}}
    \end{align*}
    and
    \begin{align*}
        \D = \rule{DF-Sink}{\overset{\D_0}{\typestep{\Gamma}{a}{L}}}
        {\typestep{\Gamma}{\sink{a}}{\emptyset}}
    \end{align*}
    Let $\D$ be the derivation tree of $\typestep{\Gamma}{\defaultsink}{\Delta}$.
    Then we have two cases, depending on $a$:\\
    \textbf{Case 1:}
    \begin{align*}
        \E_0 = \bsrule{EA-Source}{\bigstep{a_0}{\store}{\flagged}}
        {\bigstep{\source{a_0}}{\store}{\tracked}}
    \end{align*}
    Then we get
    \begin{align*}
        \D_0 = \rule{DF-Source}{\typestep{\Gamma}{a_0}{L_0}}
        {\typestep{\Gamma}{\source{a_0}}{\ltracked}}
    \end{align*}
    and with $L_t = \ltracked, \Gamma_t = \Gamma$ the theorem follows.\\
    \textbf{Case 2:}
    \begin{align*}
        \E_0 = \bsrule{EA-Loc}{}{\bigstep{X}{\store}{\store(X)}}
    \end{align*}
    Then we have 
    \begin{align*}
        \D_0 = \rule{DF-Loc}{}{\typestep{\Gamma}{X}{\Gamma(X)}}
    \end{align*}
    Obviously we have $\store(X) = \tracked$.
    By~\autoref{thm:progress} we get that $\Gamma$ matches $\store$, so we get 
    $\Gamma(X) = \ltracked$ or $\Gamma(X)= \lunknown$ as desired.
\end{proof}

\begin{corollary}
    Let $(s, \Gamma_s, \Delta_s)$ be a program in SSA form and define $\Gamma$ by
    \begin{align*}
        \Gamma: &\Gamma_s \to \lattice\\
        &X \mapsto \lclean
    \end{align*}
    Let $\D$ be the derivation of $\typestep{\Gamma}{s}{\Delta}$ using the DF rules.
    The algorithm that outputs \text{HAS\_FLOW} if $\D$ contains a derivation of form
    \begin{equation*}
        \rule{DF-Sink}{\typestep{\Gamma}{a}{\ltracked}}{\typestep{\Gamma}{\sink{a}}{\emptyset}}
    \end{equation*}
    and, in the absence of that, outputs \text{UNKOWN} if $\D$ contains a derivation of form
    \begin{equation*}
        \rule{DF-Sink}{\typestep{\Gamma}{a}{\lunknown}}{\typestep{\Gamma}{\sink{a}}{\emptyset}}
    \end{equation*}
    and, in the absence of that, outputs \text{NO\_FLOW}, is a sound dataflow algorithm.
\end{corollary}

\iffalse
\subsection{A Dataflow Algorithm}
In this section, we present a dataflow algorithm.
Then we will prove that this algorithm is a sound dataflow algorithm.
The algorithm is presented in terms of type analysis, i.e.\ every statement in 
SSA-dIMP gets a dataflow type associated with it.

Let $\lattice = \{\lclean, \ltracked, \lunknown\}$ and
$\Gamma, \Delta: \Loc \partialf \lattice$.
Every variable encountered in the program is marked with a value in the finite join-semilattice
\lattice.
Thus, it is either marked with \lclean (the variable
is clean, i.e.\ does not contain a value originating from a dataflow source), \lunknown
(it is unknown whether the variable contains a value originating from a source) or \ltracked
(the variable contains a tracked value from a dataflow source).
We define the following poset structure on it:
TODO nice picture, \lunknown is the top element, no bottom element.
Then the join operator $\join: \lattice \times \lattice \to \lattice$ is 
obviously defined.

We define the following rules:\\
Judgement \fbox{$\typestep{\Gamma}{a}{\lattice}$}:
\begin{align*}
    &\rule{DF-Num}{}{\typestep{\Gamma}{n}{\lclean}}\qquad
    \rule{DF-Loc}{}{\typestep{\Gamma}{X}{\Gamma(X)}}\qquad%\text{($X \in \Gamma$)}\qquad
    \rule{DF-Source}{}{\typestep{\Gamma}{\source{a}}{\ltracked}}\\
    &\rule{DF-Plus}{}{\typestep{\Gamma}{a_0+a_1}{\lclean}}\quad
    \rule{DF-Minus}{}{\typestep{\Gamma}{a_0-a_1}{\lclean}}\quad
    \rule{DF-Times}{}{\typestep{\Gamma}{a_0 \times a_1}{\lclean}}
\end{align*}
Judgement \fbox{$\typestep{\Gamma;\Delta_0;\Delta_1}{\defaultphilist}{\Delta}$}:
\begin{align*}
    &\rule{DF-$\varphi$}{}{\typestep{\Gamma;\Delta_0;\Delta_1}{\defaultphilist}
    {[X_1 \mapsto (\Gamma \union \Delta_0)(Y_1) \join (\Gamma \union \Delta_1)(Z_1), \ldots]}}\\
\end{align*}
Judgement \fbox{$\typestep{\Gamma}{s}{\Delta}$}:
\begin{align*}
    &\rule{DF-Sink}{}{\typestep{\Gamma}{\sink{a}}{\emptyset}}\qquad
    \rule{DF-Skip}{}{\typestep{\Gamma}{\skipcmd}{\emptyset}}\\
    &\rule{DF-Assign}{\typestep{\Gamma}{a}{L}}{\typestep{\Gamma}{\defaultstore}{[X \mapsto L]}}\\% \text{($X \notin \Gamma$)}\\
    &\rule{DF-Seq}{\typestep{\Gamma}{s_0}{\Delta_0}\qquad
    \typestep{\Gamma \cup \Delta_0}{s_1}{\Delta_1}}{\typestep{\Gamma}{\defaultssaseq}{\Delta_0 \cup \Delta_1}}\\
    &\rule{DF-If}{\typestep{\Gamma}{s_0}{\Delta_0}\qquad \typestep{\Gamma}{s_1}{\Delta_1}\qquad
    \typestep{\Gamma;\Delta_0;\Delta_1}{\defaultphilist}{\Delta}}
    {\typestep{\Gamma}{\defaultssaif}{\Delta}}\\
    &\rule{DF-While}{\typestep{\Gamma;\emptyset;\Delta_1}{\defaultphilist}{\Delta}\qquad
    \typestep{\Gamma \cup \Delta}{s_0}{\Delta_1}}
    {\typestep{\Gamma}{\defaultssawhile}{\Delta}}
\end{align*}
\fi


% Use these proofs as inspiration for the blue part, but they are not correct anymore with the
% new changes to the semantics (filters for phi nodes)
\iffalse
% TODO what does "is in SSA form" mean?
\subsubsection*{Proof that SSA-dIMP is in SSA Form}
In this section we show that a SSA-dIMP program together with the SSA type derivation
is in fact in SSA form.
\begin{lemma}
    \label{lem:phi-ssa-derivation}
    For any derivation of form $\typestep{\Gamma;\Delta_0;\Delta_1}{\defaultphilistn}{\Delta}$
    it holds that $\Delta = \{X_1, \ldots, X_n\}$ and $\Gamma \cap \Delta = \emptyset$.
\end{lemma}
\begin{proof}
    There is only one rule available for derivations of this kind, we we have
    \begin{align*}
        \D = \rule{SSA-$\varphi$}{}{\typestep{\Gamma;\Delta_0;\Delta_1}{\defaultphilistn}{\{X_1, \ldots, X_n\}}}
    \end{align*}
    We have $\Delta = \{X_1, \ldots, X_n\}$ by definition.
    Then $\Gamma \cap \Delta = \emptyset$ holds because one of the side-conditions
    specifies that for $i \in \{1, \ldots, n\}$, we have that $X_i \notin \Gamma$.
\end{proof}

\begin{lemma}
    \label{lem:phi-bs-derivation}
    Let $\E$ be a bigstep derivation of form $\bigsteppl{\defaultphilistn}{\store}{\store''}{\store'}$
    (or $\bigsteppr{\defaultphilistn}{\store}{\store''}{\store'}$)
    with a SSA derivation $\typestep{\Gamma;\Delta_0;\Delta_1}{\defaultphilistn}{\Delta}$
    and $\dom{\sigma} = \Gamma$.
    Then $\store_0 = [X_1 \coloneqq \flagged[n_i][i], \ldots]$, $\store' = \store \dunion \store_0$
    and $\dom{\store_0} = \Delta$.
\end{lemma}
\begin{proof}
    The lemma is obvious, as only one bigstep rule and one SSA rule are available.
    \autoref{lem:phi-ssa-derivation} implies that the unions are in fact disjoint.
\end{proof}

\begin{theorem}
    \label{thm:gamma-delta-disjoint}
    If $\typestep{\Gamma}{s}{\Delta}$ holds, then $\Gamma \cap \Delta = \emptyset$.
\end{theorem}
\begin{proof}
    Let $\D$ be a derivation of $\typestep{\Gamma}{s}{\Delta}$.
    We prove the theorem by induction over the derivation tree.\\
    \textbf{Case 1:}
    \begin{align*}
        \D = \rule{SSA-Skip}{}{\typestep{\Gamma}{\skipcmd}{\emptyset}}
    \end{align*}
    Obvious.\\
    \textbf{Case 2:}
    \begin{align*}
        \D = \rule{SSA-Sink}{\typestmt{\Gamma}{a}}{\typestep{\Gamma}{\defaultsink}{\emptyset}}
    \end{align*}
    Obvious.\\
    \textbf{Case 3:}
    \begin{align*}
        \D = \rule{SSA-Assign}{\typestmt{\Gamma}{a}}{\typestep{\Gamma}{\defaultstore}{\{X\}}}
    \end{align*}
    As the side condition for the rule is $X \notin \Gamma$, it follows immediately that 
    $\Gamma \cap \{X\} = \emptyset$ holds.\\
    \textbf{Case 4:}
    \begin{align*}
        \D = \rule{SSA-Seq}{\overset{\D_0}{\typestep{\Gamma}{s_0}{\Delta_0}}\qquad
        \overset{\D_1}{\typestep{\Gamma \cup \Delta_0}{s_1}{\Delta_1}}}{\typestep{\Gamma}{\defaultssaseq}{\Delta_0 \cup \Delta_1}}
    \end{align*}
    By IH on $\D_0$ we get that $\Gamma \cap \Delta_0 = \emptyset$ and by IH on 
    $\D_1$ we get that $\Gamma \cap \Delta_1 = \emptyset$.
    Thus we have $(\Delta_0 \cup \Delta_1) \cap \Gamma = \emptyset$.\\
    \textbf{Case 5:}
    \begin{align*}
        \D = \rule{SSA-If}{\typestmt{\Gamma}{b}\qquad
        \typestep{\Gamma}{s_0}{\Delta_0}\qquad \typestep{\Gamma}{s_1}{\Delta_1}\qquad
        \typestep{\Gamma;\Delta_0;\Delta_1}{\philist}{\Delta}}
        {\typestep{\Gamma}{\defaultssaif}{\Delta}}
    \end{align*}
    The result follows with~\autoref{lem:phi-ssa-derivation}.\\
    \textbf{Case 6:}
    \begin{align*}
        \D = \rule{SSA-While}{\typestep{\Gamma;\emptyset;\Delta_1}{\philist}{\Delta}\qquad
        \typestmt{\Gamma \cup \Delta}{b}\qquad\typestep{\Gamma \cup \Delta}{s_0}{\Delta_1}}
        {\typestep{\Gamma}{\defaultssawhile}{\Delta}}
    \end{align*}
    The result follows again with~\autoref{lem:phi-ssa-derivation}.\\
\end{proof}

\begin{theorem}
    If $\typestep{\Gamma}{s}{\Delta}$, $\text{dom } \store = \Gamma$ and
    $\bigstep{s}{\store}{\store'}$, then $\store' = \store \dunion \store_0$
    and $\dom{\store_0} = \Delta$.
\end{theorem}
\begin{proof}
    Let $\D$ be a derivation of $\typestep{\Gamma}{s}{\Delta}$.
    Let $\E$ be a derivation of $\bigstep{s}{\store}{\store'}$.
    We prove the theorem by induction over the derivation tree.\\
    \textbf{Case 1:}
    \begin{align*}
        \D = \rule{SSA-Skip}{}{\typestep{\Gamma}{\skipcmd}{\emptyset}}
    \end{align*}
    Then we have $s = \skipcmd$,
    \begin{align*}
        \E = \rule{EC-Skip}{}{\bigstep{\skipcmd}{\store}{\store}}
    \end{align*}
    $\store' = \store$ and $\dom{\store_0} = \emptyset$.\\
    \textbf{Case 2:}
    \begin{align*}
        \D = \rule{SSA-Sink}{\typestmt{\Gamma}{a}}{\typestep{\Gamma}{\defaultsink}{\emptyset}}
    \end{align*}
    Then we have $s = \defaultsink$,
    \begin{align*}
        \E =     \bsrule{EC-Sink}{\bigstep{a}{\store}{\clean{}}}
        {\bigstep{\defaultsink}{\store}{\store}}    
    \end{align*}
    $\store' = \store$ and $\dom{\store_0} = \emptyset$.\\
    \begin{landscape}
        \textbf{Case 3:}
        \begin{align*}
            \D = \rule{SSA-While}{\overset{\D_0}{\typestep{\Gamma;\emptyset;\Delta_1}{\philist}{\Delta}}\qquad
            \typestmt{\Gamma \cup \Delta}{b}\qquad
            \typestep{\Gamma \cup \Delta}{s_0}{\Delta_1}}
            {\typestep{\Gamma}{\defaultssawhile}{\Delta}}
        \end{align*}
        Then we have $s = \defaultssawhile$ and
        \begin{align*}
            \E = \bsrule{EC-While}{\overset{\E_0}{\bigsteppl{\philist}{\store}{\store}{\store''}} \ 
            \overset{\E_1}{\bigstepw{\defaultssawhile}{\store}{\store''}{\store'}}}
            {\bigstep{\defaultssawhile}{\store}{\store'}}
        \end{align*}
        By applying~\autoref{lem:phi-bs-derivation} on $\E_0$ with $\D_0$ we get that
        $\store'' = \store \dunion \store_1$ with $\dom{\store_1} = \Delta$.
            
        \begin{claim}
            First, we prove by induction over derivations $\E^w$ of 
            $\bigstepw{\defaultssawhile}{\store}{\Sigma''}{\Sigma'}$
            with SSA derivation $\D^w$ of $\typestep{\Gamma}{\defaultssawhile}{\Delta}$,
            $\Sigma'' = \store \dunion \Sigma_1$ and $\dom{\Sigma_1} = \Delta$
            we have that $\Sigma' = \store \dunion \Sigma_0$ with $\dom{\Sigma_0} = \Delta$.
        \end{claim}
        \begin{claimproof}
            Note that we have
            \begin{align*}
                \D^w = \rule{SSA-While}{\overset{\D^w_0}{\typestep{\Gamma;\emptyset;\Delta_1}{\philist}{\Delta}}\qquad
                \typestmt{\Gamma \cup \Delta}{b}\qquad
                \overset{\D^w_1}{\typestep{\Gamma \cup \Delta}{s_0}{\Delta_1}}}
                {\typestep{\Gamma}{\defaultssawhile}{\Delta}}
            \end{align*}
            \emph{Case 1:}
            \begin{align*}
                \E^w = \bsrule{EW-WhileF}{\bigstep{b}{\Sigma''}{\bfalse}}
                {\bigstepw{\defaultssawhile}{\store}{\Sigma''}{\Sigma''}}
            \end{align*}
            Thus we have $\Sigma'' = \Sigma'$, and we get the desired statement immediately with $\Sigma_0 = \Sigma_1$.\\
            \emph{Case 2:}
            \begin{align*}
                \E^w = \bsrule{EW-WhileT}{\bigstep{b}{\Sigma''}{\btrue} \  
                \bigstep{s_0}{\Sigma''}{\Sigma'''} \  
                \overset{\E^w_0}{\bigsteppr{\philist}{\store}{\Sigma'''}{\Sigma''''}} \ 
                \bigstepw{\defaultssawhile}{\store}{\Sigma''''}{\Sigma'}}
                {\bigstepw{\defaultssawhile}{\store}{\Sigma''}{\Sigma'}}
            \end{align*}
            By applying~\autoref{lem:phi-bs-derivation} on $\E_0$ with $\D^w_0$ we get that
            $\Sigma''' = \sigma \dunion \Sigma_2$ with $\dom{\Sigma_2} = \Delta$.
            By the IH on $\E^w_1$ with $\D^w$ (which we can apply here because we have the split of $\Sigma'''$)
            we get that $\Sigma' = \sigma \dunion \Sigma_0$ with $\dom{\Sigma_0} = \Delta$.
        \end{claimproof}
    
        Because we have $\store'' = \sigma \dunion \sigma_1$ with $\dom{\sigma_1} = \Delta$, 
        we can apply the claim to $\E_1$ with $\D$ and get that $\sigma' = \sigma \dunion \sigma_0$
        and $\dom{\sigma_0} = \Delta$ as desired.
    \end{landscape}
    \textbf{Case 4:}
    \begin{align*}
        \D = \rule{SSA-Assign}{\typestmt{\Gamma}{a}}{\typestep{\Gamma}{\defaultstore}{\{X\}}}
    \end{align*}
    Then we have $s = \defaultstore$ and
    \begin{align*}
        \E = \bsrule{EC-Assign}{\bigstep{a}{\store}{\flagged{}}}
        {\bigstep{\defaultstore}{\store}{\storeassign{\store}{X \mapsto \flagged{}]}}}
    \end{align*}
    Furthermore, we obviously get $\dom{\store_0} = \{X\} = \Delta$.
    As the side-condition for \textsc{SSA-Assign} specifies that $X \notin \Gamma$
    and we have $\dom{\store} = \Gamma$ as assumption, we also have $X \notin \dom{\store}$,
    so the union is disjoint as postulated.\\
    \textbf{Case 5:}
    \begin{align*}
        \D = \rule{SSA-Seq}{\overset{\D_0}{\typestep{\Gamma}{s_0}{\Delta_0}}\qquad
        \overset{\D_1}{\typestep{\Gamma \cup \Delta_0}{s_1}{\Delta_1}}}{\typestep{\Gamma}{\defaultssaseq}{\Delta_0 \cup \Delta_1}}
    \end{align*}
    Then we have $s = \defaultssaseq$ and
    \begin{align*}
        \E =\bsrule{EC-Seq}{\overset{\E_0}{\bigstep{s_0}{\sigma}{\store''}} \qquad 
        \overset{\E_1}{\bigstep{s_1}{\store''}{\store'}}}
        {\bigstep{\defaultssaseq}{\store}{\store'}}
    \end{align*}
    By IH on $\D_0$ with $\E_0$ we get that $\sigma'' = \sigma \dunion \tilde{\store}''$ 
    with $\dom{\tilde{\store}''} = \Delta_0$.
    Thus, $\dom{\sigma''} = \Gamma \union \Delta_0$.
    Then, by IH on $\D_1$ with $\E_1$ we get that
    $$\sigma' = \sigma'' \dunion \tilde{\store}' = \sigma \dunion (\tilde{\store}'' \dunion \tilde{\store}')$$
    and $\dom{\tilde{\store}'} = \Delta_1$.
    Thus, we have $\sigma_0 = \tilde{\store}'' \dunion \tilde{\store}'$
    and $\dom{\sigma_0} = \Delta_0 \union \Delta_1$ as required.
    \autoref{thm:gamma-delta-disjoint} implies that all the unions are disjoint.\\
    \textbf{Case 6:}
    \begin{align*}
        \D = \rule{SSA-If}{\typestmt{\Gamma}{b}\qquad
        \typestep{\Gamma}{s_0}{\Delta_0}\qquad \typestep{\Gamma}{s_1}{\Delta_1}\qquad
        \overset{\D_0}{\typestep{\Gamma;\Delta_0;\Delta_1}{\philist}{\Delta}}}
        {\typestep{\Gamma}{\defaultssaif}{\Delta}}
    \end{align*}
    Then we have $s = \defaultssaif$ and
    two subcases.\\
    \textbf{Subcase 1}:
    \begin{align*}
        \E = \rule{SSA-IfT}{\bigstep{b}{\store}{\btrue}\qquad \bigstep{s_0}{\store}{\store''}
        \qquad \overset{\E_0}{\bigsteppl{\philist}{\store}{\sigma''}{\sigma'}}}
        {\bigstep{\defaultssaif}{\store}{\store'}}
    \end{align*}
    The result follows immediately from~\autoref{lem:phi-bs-derivation} applied to $\E_0$ with $\D_0$.\\
    \textbf{Subcase 2}:
    \begin{align*}
        \E = \rule{SSA-IfF}{\bigstep{b}{\store}{\bfalse}\qquad \bigstep{s_1}{\store}{\store''}
        \qquad \overset{\E_0}{\bigsteppr{\philist}{\store}{\sigma''}{\sigma'}}}
        {\bigstep{\defaultssaif}{\store}{\store'}}
    \end{align*}
    The result follows immediately from~\autoref{lem:phi-bs-derivation} applied to $\E_0$ with $\D_0$.
\end{proof}
%\begin{corollary}
%    Following from these two theorems, it is immediately that in
%    $\bigstep{s}{\store}{\store'}$ with $\typestep{\Gamma}{s}{\Delta}$ every variable is only 
%    written to once, as $\Gamma \cap \Delta = \emptyset$ and $\store' = \store \dunion \sigma_0$
%    with $\dom{\store_0} = \Delta$ implies that the result store for commands append-only.
%\end{corollary}
\fi
