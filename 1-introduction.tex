% !TEX root = main.tex
\section{Introduction}
\subsection{Static Analysis}
Static analysis is the analysis of computer programs, while not executing the program.
Usually, the static analysis has access to the source code of the analyzed program.
Static analysis has several goals, among them are to support the programmer in finding (possible) mistakes and
security issues in their programs.
Furthermore, static analysis is also employed by compilers in order to optimize code.
If for example a compiler can prove that the condition expression of an if statement is always false,
a branch instruction can be avoided.
In this project outside the course scope, we use a static analyser that is developed
solely to find bugs and report them to the developers.

\subsection{Description of CodeQL}
The software package we are using for static analysis is called \emph{CodeQL}.
It was first developed by a company called Semmle and sold to corporate customers worldwide.
Additionally, open-source projects hosted on GitHub and other open-source platforms could
get analysis results of their projects for free on the LGTM.com platform\footnote{LGTM 
is an acronym for \emph{Looks good to me}, a common statement of reviewers before merging
pull requests.}.

In September 2019, GitHub announced that they bought Semmle.
Following the acquisition, the CodeQL CLI utility was released to the general public,
which allows the analysis of any software, not only publicly hosted projects.
However, the license specifies that any usage has to either be academic research,
or that the analyzed codebase is released under an OSI-approved open-source license.
Still, this was quite a step up from only having code that has been uploaded to
GitHub analyzed.
During this project, the CodeQL CLI utility was used under the academic research clause.

Throughout the report, there are links to CodeQL analyses on open-source projects.
These refer to a single analysis (called query in CodeQL lingo), as well as a specific result
set associated with a project revision at the time of writing the report.
We expect that these links are snapshots, i.e.\ as long as they are available,
the content does not change.
% TODO terminology callable, argument, parameter


\subsubsection*{Architecture of CodeQL}
Now we give a short overview of the CodeQL architecture, as well as where our
project fits in. 
The CodeQL tool is built upon the domain specific language QL\footnote{QL is an acronym for \emph{Query Language}}
that enables declarative, logic-based programming.
Every analysis of a program is described as a query of a relational database built using 
the program's source code. These queries are written in QL.

In order to analyze source code, it first needs to be processed into a database representation.
For each language an \emph{extractor} parses the source code and outputs a database file.
The extractor is language specific and usually hooks into a (possibly modified) compiler for that language.
The output of the extractor is a relational database in a language-specific \emph{database schema}.
This database schema evolves along with the language, as well as extractor capabilities.
For example, the Java database schema changed when preliminary support for the Java 13 yield statement was
added to the extractor.

The \emph{database engine} allows users to query the database file produced by the extractor.
These queries, written in QL, implement the actual static analyses.
Both the database engine and the QL language are agnostic to the language the analyzed source code 
is written in.
This allows developers at GitHub with relative ease to support new languages in the CodeQL ecosystem.
In theory, QL queries are also independent of the language the analyzed source code is written.
However, in practice queries are tied to the language of the analyzed source code,
as they depend on the language-specific database schema.
Furthermore, queries can't gloss over language-specific semantics either {---} one example of many would be
that signed integer overflow needs to be treated differently in Java than in C/C++.

For each language, a set of \emph{libraries} assists in the development of queries.
These libraries are implemented in QL.
The libraries implement features such as taint tracking, dataflow analysis or control flow graphs.
For every language supported by the CodeQL analyzers, developers usually re-implement all of these libraries from
scratch, as sharing components across languages is quite difficult.
The only exception is the dataflow library, which is separated into a language-agnostic and 
language-specific part.
This language-agnostic part of the dataflow library is shared between the libraries for Java, C/C++ and C\#.

Using those libraries, developers at GitHub write \emph{queries} to detect bugs in the analyzed program.
For example, one query detects when variable dereference in Java might be null.
Another query detects if user input may end up in a database query, without the user input being 
sanitized properly for use in such a query.
Queries often rely on the supporting libraries to do the heavy lifting, e.g.\ the SQL injection detection 
is built on top of the dataflow library.

All queries as well as the supporting libraries are open-source and published 
on GitHub\footnote{\url{https://github.com/Semmle/ql}}.
Most of the extractors and the query engine are only available in compiled form under a 
proprietary license\footnote{\url{https://github.com/github/codeql-cli-binaries}}.
While the license is quite restrictive,
usage of the CodeQL CLI utility for academic research is explicitly allowed.

Our project outside the course scope contributes improvements to the dataflow library,
both the shared and the language-specific part. We only implemented the language-specific 
functionality, and a GitHub employee provided stubs for C/C++ and C\#.
The individual features are discussed in the next chapters.

%For a detailed description of the QL language

\subsection{Philosophy of Bug Finding}
Using static analysis for bug finding is lacking in the theoretical foundation {---} 
analyses are often neither sound nor complete.
This means that a query can report \emph{false positives}, problems flagged by the query that 
are not bugs at all.
Furthermore, queries can also not report instances of a bug which are present in the code,
that instance is then called a \emph{false negative}.
Obviously both false positives and negatives are not desirable, but static analyzers go a long way
to reduce false positives as a means to reduce noise.
If false positives are reduced, almost every problem flagged by an analysis is a real bug.
This makes the static analyzer a very useful tool.

However, this makes it difficult to express in a theoretical framework to prove that 
an analysis is useful, as this approach eludes an easy definition.
In this report, we deal with this problem by reducing the complexity of the analyzed language,
so in the theoretical setting we are dealing with a (provably) sound analysis, i.e.\ 
an analysis that has no false negatives.

\subsection{Evaluation Model of QL}
\cite{qlpaper}
Every predicate is computed bottoms-up, so when a predicate is encountered, its
tuple set is computed.
Recursive predicates are computed as fixed-point iterations, which means that the database engine 
first adds the tuple sets arising from the base cases, and then from the recursive cases, until
no more tuples can be added. (TODO improve).
Mutual recursions are TODO.

Another useful feature of QL is that it includes syntactic sugar to compute the reflexive-transitive
and the transitive closure of predicates.
For example, a predicate \texttt{getSucc} on control flow nodes gives the set of all reachable
nodes by invoking \texttt{getSucc*}.

\subsection{QL And Relational Database TODO title}
At the heart of QL lives a relational database, and QL is designed to query a relational database.
Every predicate, the basic notion of a BLA, can be regarded as a tuple.

% TODO cite qlpaper

% TODO can you build an infinite predicate, or does the compiler check that for you?
% equivalent to SQL, but what about recursion?